
zephyr.elf:     file format elf64-littleriscv


Disassembly of section vector:

0000000080000000 <__start>:

	/*
	 * Set mtvec (Machine Trap-Vector Base-Address Register)
	 * to __irq_wrapper.
	 */
	la t0, __irq_wrapper
    80000000:	00000297          	auipc	t0,0x0
    80000004:	01428293          	addi	t0,t0,20 # 80000014 <__irq_wrapper>
	csrw mtvec, t0
    80000008:	30529073          	csrw	mtvec,t0

	/* Jump to __reset */
	tail __reset
    8000000c:	0040006f          	j	80000010 <__reset>

Disassembly of section reset:

0000000080000010 <__reset>:
	/*
	 * jump to __initialize
	 * use call opcode in case __initialize is far away.
	 * This will be dependent on linker.ld configuration.
	 */
	call __initialize
    80000010:	019010ef          	jal	ra,80001828 <__initialize>

Disassembly of section exceptions:

0000000080000014 <__irq_wrapper>:
	 * Save caller-saved registers on current thread stack.
	 * NOTE: need to be updated to account for floating-point registers
	 * floating-point registers should be accounted for when corresponding
	 * config variable is set
	 */
	STORE_CALLER_SAVED()
    80000014:	f6010113          	addi	sp,sp,-160
    80000018:	00113023          	sd	ra,0(sp)
    8000001c:	00413423          	sd	tp,8(sp)
    80000020:	00513823          	sd	t0,16(sp)
    80000024:	00613c23          	sd	t1,24(sp)
    80000028:	02713023          	sd	t2,32(sp)
    8000002c:	03c13423          	sd	t3,40(sp)
    80000030:	03d13823          	sd	t4,48(sp)
    80000034:	03e13c23          	sd	t5,56(sp)
    80000038:	05f13023          	sd	t6,64(sp)
    8000003c:	04a13423          	sd	a0,72(sp)
    80000040:	04b13823          	sd	a1,80(sp)
    80000044:	04c13c23          	sd	a2,88(sp)
    80000048:	06d13023          	sd	a3,96(sp)
    8000004c:	06e13423          	sd	a4,104(sp)
    80000050:	06f13823          	sd	a5,112(sp)
    80000054:	07013c23          	sd	a6,120(sp)
    80000058:	09113023          	sd	a7,128(sp)

skip_store_fp_caller_saved:
#endif /* CONFIG_FPU && CONFIG_FPU_SHARING */

	/* Save MEPC register */
	csrr t0, mepc
    8000005c:	341022f3          	csrr	t0,mepc
	RV_OP_STOREREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
    80000060:	08513423          	sd	t0,136(sp)

	/* Save SOC-specific MSTATUS register */
	csrr t0, mstatus
    80000064:	300022f3          	csrr	t0,mstatus
	RV_OP_STOREREG t0, __z_arch_esf_t_mstatus_OFFSET(sp)
    80000068:	08513823          	sd	t0,144(sp)
	 * SOCs (like pulpino or riscv-qemu), the MSB is never set to indicate
	 * interrupt. Hence, check for interrupt/exception via the __soc_is_irq
	 * function (that needs to be implemented by each SOC). The result is
	 * returned via register a0 (1: interrupt, 0 exception)
	 */
	jal ra, __soc_is_irq
    8000006c:	23c000ef          	jal	ra,800002a8 <__soc_is_irq>

	/* If a0 != 0, jump to is_interrupt */
	addi t1, x0, 0
    80000070:	00000313          	li	t1,0
	bnez a0, is_interrupt
    80000074:	04051063          	bnez	a0,800000b4 <is_interrupt>
	/*
	 * If the exception is the result of an ECALL, check whether to
	 * perform a context-switch or an IRQ offload. Otherwise call _Fault
	 * to report the exception.
	 */
	csrr t0, mcause
    80000078:	342022f3          	csrr	t0,mcause
	li t2, SOC_MCAUSE_EXP_MASK
    8000007c:	fff0039b          	addiw	t2,zero,-1
    80000080:	03f39393          	slli	t2,t2,0x3f
    80000084:	fff38393          	addi	t2,t2,-1
	and t0, t0, t2
    80000088:	0072f2b3          	and	t0,t0,t2
	li t1, SOC_MCAUSE_ECALL_EXP
    8000008c:	00b00313          	li	t1,11

	/*
	 * If mcause == SOC_MCAUSE_ECALL_EXP, handle system call from
	 * kernel thread.
	 */
	beq t0, t1, is_kernel_syscall
    80000090:	00628a63          	beq	t0,t1,800000a4 <is_kernel_syscall>
	 * Stack pointer is pointing to a z_arch_esf_t structure, pass it
	 * to _Fault (via register a0).
	 * If _Fault shall return, set return address to
	 * no_reschedule to restore stack.
	 */
	addi a0, sp, 0
    80000094:	00010513          	mv	a0,sp
	RV_OP_LOADREG t1, _kernel_offset_to_current(t0)
	RV_OP_LOADREG t0, _thread_offset_to_priv_stack_start(t1)
	RV_OP_STOREREG sp, _thread_offset_to_user_sp(t1) /* Update user SP */
	addi sp, t0, CONFIG_PRIVILEGED_STACK_SIZE
#else
	la ra, no_reschedule
    80000098:	00000097          	auipc	ra,0x0
    8000009c:	1a408093          	addi	ra,ra,420 # 8000023c <no_reschedule>
#endif /* CONFIG_USERSPACE */

	tail _Fault
    800000a0:	7400106f          	j	800017e0 <_Fault>

00000000800000a4 <is_kernel_syscall>:
	 * again upon exiting the ISR.
	 *
	 * It's safe to always increment by 4, even with compressed
	 * instructions, because the ecall instruction is always 4 bytes.
	 */
	RV_OP_LOADREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
    800000a4:	08813283          	ld	t0,136(sp)
	addi t0, t0, 4
    800000a8:	00428293          	addi	t0,t0,4
	RV_OP_STOREREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
    800000ac:	08513423          	sd	t0,136(sp)
	j z_riscv_user_mode_enter_syscall
#endif /* CONFIG_USERSPACE */
	/*
	 * Go to reschedule to handle context-switch
	 */
	j reschedule
    800000b0:	0900006f          	j	80000140 <reschedule>

00000000800000b4 <is_interrupt>:
	 * Save current thread stack pointer and switch
	 * stack pointer to interrupt stack.
	 */

	/* Save thread stack pointer to temp register t0 */
	addi t0, sp, 0
    800000b4:	00010293          	mv	t0,sp

	/* Switch to interrupt stack */
	la t2, _kernel
    800000b8:	00003397          	auipc	t2,0x3
    800000bc:	22838393          	addi	t2,t2,552 # 800032e0 <_kernel>
	RV_OP_LOADREG sp, _kernel_offset_to_irq_stack(t2)
    800000c0:	0083b103          	ld	sp,8(t2)

	/*
	 * Save thread stack pointer on interrupt stack
	 * In RISC-V, stack pointer needs to be 16-byte aligned
	 */
	addi sp, sp, -16
    800000c4:	ff010113          	addi	sp,sp,-16
	RV_OP_STOREREG t0, 0x00(sp)
    800000c8:	00513023          	sd	t0,0(sp)

00000000800000cc <on_irq_stack>:
	la t2, _kernel
#endif /* !CONFIG_USERSPACE && !CONFIG_PMP_STACK_GUARD */

on_irq_stack:
	/* Increment _kernel.cpus[0].nested variable */
	lw t3, _kernel_offset_to_nested(t2)
    800000cc:	0003ae03          	lw	t3,0(t2)
	addi t3, t3, 1
    800000d0:	001e0e13          	addi	t3,t3,1
	sw t3, _kernel_offset_to_nested(t2)
    800000d4:	01c3a023          	sw	t3,0(t2)
#ifdef CONFIG_TRACING_ISR
	call sys_trace_isr_enter
#endif

	/* Get IRQ causing interrupt */
	csrr a0, mcause
    800000d8:	34202573          	csrr	a0,mcause
	li t0, SOC_MCAUSE_EXP_MASK
    800000dc:	fff0029b          	addiw	t0,zero,-1
    800000e0:	03f29293          	slli	t0,t0,0x3f
    800000e4:	fff28293          	addi	t0,t0,-1
	and a0, a0, t0
    800000e8:	00557533          	and	a0,a0,t0

	/*
	 * Clear pending IRQ generating the interrupt at SOC level
	 * Pass IRQ number to __soc_handle_irq via register a0
	 */
	jal ra, __soc_handle_irq
    800000ec:	1ac000ef          	jal	ra,80000298 <__soc_handle_irq>

	/*
	 * Call corresponding registered function in _sw_isr_table.
	 * (table is 2-word wide, we should shift index accordingly)
	 */
	la t0, _sw_isr_table
    800000f0:	00003297          	auipc	t0,0x3
    800000f4:	b5828293          	addi	t0,t0,-1192 # 80002c48 <_sw_isr_table>
	slli a0, a0, (RV_REGSHIFT + 1)
    800000f8:	00451513          	slli	a0,a0,0x4
	add t0, t0, a0
    800000fc:	00a282b3          	add	t0,t0,a0

	/* Load argument in a0 register */
	RV_OP_LOADREG a0, 0x00(t0)
    80000100:	0002b503          	ld	a0,0(t0)

	/* Load ISR function address in register t1 */
	RV_OP_LOADREG t1, RV_REGSIZE(t0)
    80000104:	0082b303          	ld	t1,8(t0)

	/* Call ISR function */
	jalr ra, t1
    80000108:	000300e7          	jalr	t1

000000008000010c <on_thread_stack>:

on_thread_stack:
	/* Get reference to _kernel */
	la t1, _kernel
    8000010c:	00003317          	auipc	t1,0x3
    80000110:	1d430313          	addi	t1,t1,468 # 800032e0 <_kernel>

	/* Decrement _kernel.cpus[0].nested variable */
	lw t2, _kernel_offset_to_nested(t1)
    80000114:	00032383          	lw	t2,0(t1)
	addi t2, t2, -1
    80000118:	fff38393          	addi	t2,t2,-1
	sw t2, _kernel_offset_to_nested(t1)
    8000011c:	00732023          	sw	t2,0(t1)

#if !defined(CONFIG_USERSPACE) && !defined(CONFIG_PMP_STACK_GUARD)
	/* Restore thread stack pointer */
	RV_OP_LOADREG t0, 0x00(sp)
    80000120:	00013283          	ld	t0,0(sp)
	addi sp, t0, 0
    80000124:	00028113          	mv	sp,t0
#endif /* !CONFIG_USERSPACE && !CONFIG_PMP_STACK_GUARD */

#ifdef CONFIG_STACK_SENTINEL
	call z_check_stack_sentinel
    80000128:	4d1010ef          	jal	ra,80001df8 <z_check_stack_sentinel>
	la t1, _kernel
    8000012c:	00003317          	auipc	t1,0x3
    80000130:	1b430313          	addi	t1,t1,436 # 800032e0 <_kernel>
	/*
	 * Check if we need to perform a reschedule
	 */

	/* Get pointer to _kernel.current */
	RV_OP_LOADREG t2, _kernel_offset_to_current(t1)
    80000134:	01033383          	ld	t2,16(t1)

	/*
	 * Check if next thread to schedule is current thread.
	 * If yes do not perform a reschedule
	 */
	RV_OP_LOADREG t3, _kernel_offset_to_ready_q_cache(t1)
    80000138:	02833e03          	ld	t3,40(t1)
	beq t3, t2, no_reschedule
    8000013c:	107e0063          	beq	t3,t2,8000023c <no_reschedule>

0000000080000140 <reschedule>:
	 * Note:
	 *   Sometimes this code is execute back-to-back before the target thread
	 *   has a chance to run. If this happens, the current thread and the
	 *   target thread will be the same.
	 */
	la t0, _kernel
    80000140:	00003297          	auipc	t0,0x3
    80000144:	1a028293          	addi	t0,t0,416 # 800032e0 <_kernel>
	RV_OP_LOADREG t2, _kernel_offset_to_current(t0)
    80000148:	0102b383          	ld	t2,16(t0)
	RV_OP_LOADREG t3, _kernel_offset_to_ready_q_cache(t0)
    8000014c:	0282be03          	ld	t3,40(t0)
	beq t2, t3, no_reschedule
    80000150:	0fc38663          	beq	t2,t3,8000023c <no_reschedule>

#if CONFIG_INSTRUMENT_THREAD_SWITCHING
	call z_thread_mark_switched_out
#endif
	/* Get reference to _kernel */
	la t0, _kernel
    80000154:	00003297          	auipc	t0,0x3
    80000158:	18c28293          	addi	t0,t0,396 # 800032e0 <_kernel>

	/* Get pointer to _kernel.current */
	RV_OP_LOADREG t1, _kernel_offset_to_current(t0)
    8000015c:	0102b303          	ld	t1,16(t0)

	/*
	 * Save callee-saved registers of current kernel thread
	 * prior to handle context-switching
	 */
	STORE_CALLEE_SAVED(t1)
    80000160:	04833823          	sd	s0,80(t1)
    80000164:	04933c23          	sd	s1,88(t1)
    80000168:	07233023          	sd	s2,96(t1)
    8000016c:	07333423          	sd	s3,104(t1)
    80000170:	07433823          	sd	s4,112(t1)
    80000174:	07533c23          	sd	s5,120(t1)
    80000178:	09633023          	sd	s6,128(t1)
    8000017c:	09733423          	sd	s7,136(t1)
    80000180:	09833823          	sd	s8,144(t1)
    80000184:	09933c23          	sd	s9,152(t1)
    80000188:	0ba33023          	sd	s10,160(t1)
    8000018c:	0bb33423          	sd	s11,168(t1)

0000000080000190 <skip_callee_saved_reg>:

	/*
	 * Save stack pointer of current thread and set the default return value
	 * of z_swap to _k_neg_eagain for the thread.
	 */
	RV_OP_STOREREG sp, _thread_offset_to_sp(t1)
    80000190:	04233423          	sd	sp,72(t1)
	la t2, _k_neg_eagain
    80000194:	00003397          	auipc	t2,0x3
    80000198:	ecc38393          	addi	t2,t2,-308 # 80003060 <_k_neg_eagain>
	lw t3, 0x00(t2)
    8000019c:	0003ae03          	lw	t3,0(t2)
	sw t3, _thread_offset_to_swap_return_value(t1)
    800001a0:	0fc32823          	sw	t3,240(t1)

	/* Get next thread to schedule. */
	RV_OP_LOADREG t1, _kernel_offset_to_ready_q_cache(t0)
    800001a4:	0282b303          	ld	t1,40(t0)

	/*
	 * Set _kernel.current to new thread loaded in t1
	 */
	RV_OP_STOREREG t1, _kernel_offset_to_current(t0)
    800001a8:	0062b823          	sd	t1,16(t0)

	/* Switch to new thread stack */
	RV_OP_LOADREG sp, _thread_offset_to_sp(t1)
    800001ac:	04833103          	ld	sp,72(t1)

	/* Restore callee-saved registers of new thread */
	LOAD_CALLEE_SAVED(t1)
    800001b0:	05033403          	ld	s0,80(t1)
    800001b4:	05833483          	ld	s1,88(t1)
    800001b8:	06033903          	ld	s2,96(t1)
    800001bc:	06833983          	ld	s3,104(t1)
    800001c0:	07033a03          	ld	s4,112(t1)
    800001c4:	07833a83          	ld	s5,120(t1)
    800001c8:	08033b03          	ld	s6,128(t1)
    800001cc:	08833b83          	ld	s7,136(t1)
    800001d0:	09033c03          	ld	s8,144(t1)
    800001d4:	09833c83          	ld	s9,152(t1)
    800001d8:	0a033d03          	ld	s10,160(t1)
    800001dc:	0a833d83          	ld	s11,168(t1)
	addi a0, sp, __z_arch_esf_t_soc_context_OFFSET
	jal ra, __soc_restore_context
#endif /* CONFIG_RISCV_SOC_CONTEXT_SAVE */

	/* Restore MEPC register */
	RV_OP_LOADREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
    800001e0:	08813283          	ld	t0,136(sp)
	csrw mepc, t0
    800001e4:	34129073          	csrw	mepc,t0

	/* Restore SOC-specific MSTATUS register */
	RV_OP_LOADREG t0, __z_arch_esf_t_mstatus_OFFSET(sp)
    800001e8:	09013283          	ld	t0,144(sp)
	csrw mstatus, t0
    800001ec:	30029073          	csrw	mstatus,t0

skip_load_fp_caller_saved_resched:
#endif /* CONFIG_FPU && CONFIG_FPU_SHARING */

	/* Restore caller-saved registers from thread stack */
	LOAD_CALLER_SAVED()
    800001f0:	00013083          	ld	ra,0(sp)
    800001f4:	00813203          	ld	tp,8(sp)
    800001f8:	01013283          	ld	t0,16(sp)
    800001fc:	01813303          	ld	t1,24(sp)
    80000200:	02013383          	ld	t2,32(sp)
    80000204:	02813e03          	ld	t3,40(sp)
    80000208:	03013e83          	ld	t4,48(sp)
    8000020c:	03813f03          	ld	t5,56(sp)
    80000210:	04013f83          	ld	t6,64(sp)
    80000214:	04813503          	ld	a0,72(sp)
    80000218:	05013583          	ld	a1,80(sp)
    8000021c:	05813603          	ld	a2,88(sp)
    80000220:	06013683          	ld	a3,96(sp)
    80000224:	06813703          	ld	a4,104(sp)
    80000228:	07013783          	ld	a5,112(sp)
    8000022c:	07813803          	ld	a6,120(sp)
    80000230:	08013883          	ld	a7,128(sp)
    80000234:	0a010113          	addi	sp,sp,160

	/* Call SOC_ERET to exit ISR */
	SOC_ERET
    80000238:	30200073          	mret

000000008000023c <no_reschedule>:
	addi a0, sp, __z_arch_esf_t_soc_context_OFFSET
	jal ra, __soc_restore_context
#endif /* CONFIG_RISCV_SOC_CONTEXT_SAVE */

	/* Restore MEPC register */
	RV_OP_LOADREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
    8000023c:	08813283          	ld	t0,136(sp)
	csrw mepc, t0
    80000240:	34129073          	csrw	mepc,t0

	/* Restore SOC-specific MSTATUS register */
	RV_OP_LOADREG t0, __z_arch_esf_t_mstatus_OFFSET(sp)
    80000244:	09013283          	ld	t0,144(sp)
	csrw mstatus, t0
    80000248:	30029073          	csrw	mstatus,t0

skip_load_fp_caller_saved:
#endif /* CONFIG_FPU && CONFIG_FPU_SHARING */

	/* Restore caller-saved registers from thread stack */
	LOAD_CALLER_SAVED()
    8000024c:	00013083          	ld	ra,0(sp)
    80000250:	00813203          	ld	tp,8(sp)
    80000254:	01013283          	ld	t0,16(sp)
    80000258:	01813303          	ld	t1,24(sp)
    8000025c:	02013383          	ld	t2,32(sp)
    80000260:	02813e03          	ld	t3,40(sp)
    80000264:	03013e83          	ld	t4,48(sp)
    80000268:	03813f03          	ld	t5,56(sp)
    8000026c:	04013f83          	ld	t6,64(sp)
    80000270:	04813503          	ld	a0,72(sp)
    80000274:	05013583          	ld	a1,80(sp)
    80000278:	05813603          	ld	a2,88(sp)
    8000027c:	06013683          	ld	a3,96(sp)
    80000280:	06813703          	ld	a4,104(sp)
    80000284:	07013783          	ld	a5,112(sp)
    80000288:	07813803          	ld	a6,120(sp)
    8000028c:	08013883          	ld	a7,128(sp)
    80000290:	0a010113          	addi	sp,sp,160

#ifdef CONFIG_PMP_STACK_GUARD
	csrrw sp, mscratch, sp
#endif /* CONFIG_PMP_STACK_GUARD */
	/* Call SOC_ERET to exit ISR */
	SOC_ERET
    80000294:	30200073          	mret

0000000080000298 <__soc_handle_irq>:
 * SOC-specific function to handle pending IRQ number generating the interrupt.
 * Exception number is given as parameter via register a0.
 */
SECTION_FUNC(exception.other, __soc_handle_irq)
	/* Clear exception number from CSR mip register */
	li t1, 1
    80000298:	00100313          	li	t1,1
	sll t0, t1, a0
    8000029c:	00a312b3          	sll	t0,t1,a0
	csrrc t1, mip, t0
    800002a0:	3442b373          	csrrc	t1,mip,t0

	/* Return */
	jalr x0, ra
    800002a4:	00008067          	ret

00000000800002a8 <__soc_is_irq>:
 * return 1 (interrupt) or 0 (exception)
 *
 */
SECTION_FUNC(exception.other, __soc_is_irq)
	/* Read mcause and check if interrupt bit is set */
	csrr t0, mcause
    800002a8:	342022f3          	csrr	t0,mcause
	li t1, SOC_MCAUSE_IRQ_MASK
    800002ac:	fff0031b          	addiw	t1,zero,-1
    800002b0:	03f31313          	slli	t1,t1,0x3f
	and t0, t0, t1
    800002b4:	0062f2b3          	and	t0,t0,t1

	/* If interrupt bit is not set, return with 0 */
	addi a0, x0, 0
    800002b8:	00000513          	li	a0,0
	beqz t0, not_interrupt
    800002bc:	00028463          	beqz	t0,800002c4 <not_interrupt>
	addi a0, a0, 1
    800002c0:	00150513          	addi	a0,a0,1

00000000800002c4 <not_interrupt>:

not_interrupt:
	/* return */
	jalr x0, ra
    800002c4:	00008067          	ret

00000000800002c8 <arch_swap>:
 * key is stored in a0 register
 */
SECTION_FUNC(exception.other, arch_swap)

	/* Make a system call to perform context switch */
	ecall
    800002c8:	00000073          	ecall
	 * Prior to unlocking irq, load return value of
	 * arch_swap to temp register t2 (from
	 * _thread_offset_to_swap_return_value). Normally, it should be -EAGAIN,
	 * unless someone has previously called arch_thread_return_value_set(..).
	 */
	la t0, _kernel
    800002cc:	00003297          	auipc	t0,0x3
    800002d0:	01428293          	addi	t0,t0,20 # 800032e0 <_kernel>

	/* Get pointer to _kernel.current */
	RV_OP_LOADREG t1, _kernel_offset_to_current(t0)
    800002d4:	0102b303          	ld	t1,16(t0)

	/* Load return value of arch_swap function in temp register t2 */
	lw t2, _thread_offset_to_swap_return_value(t1)
    800002d8:	0f032383          	lw	t2,240(t1)

	/*
	 * Unlock irq, following IRQ lock state in a0 register.
	 * Use atomic instruction csrrs to do so.
	 */
	andi a0, a0, MSTATUS_IEN
    800002dc:	00857513          	andi	a0,a0,8
	csrrs t0, mstatus, a0
    800002e0:	300522f3          	csrrs	t0,mstatus,a0

	/* Set value of return register a0 to value of register t2 */
	addi a0, t2, 0
    800002e4:	00038513          	mv	a0,t2

	/* Return */
	jalr x0, ra
    800002e8:	00008067          	ret

Disassembly of section text:

00000000800002ec <_OffsetAbsSyms>:
 * point regs
 */
GEN_ABSOLUTE_SYM(_K_THREAD_NO_FLOAT_SIZEOF,
		 STACK_ROUND_UP(sizeof(struct k_thread)));

GEN_ABS_SYM_END
    800002ec:	00008067          	ret

00000000800002f0 <main>:

char rxbuf[100];
volatile int count;

void main(void)
{
    800002f0:	fb010113          	addi	sp,sp,-80
    800002f4:	02913c23          	sd	s1,56(sp)
__syscall int uart_poll_in(const struct device *dev, unsigned char *p_char);

static inline int z_impl_uart_poll_in(const struct device *dev,
				      unsigned char *p_char)
{
	const struct uart_driver_api *api =
    800002f8:	00003497          	auipc	s1,0x3
    800002fc:	8f048493          	addi	s1,s1,-1808 # 80002be8 <__device_dts_ord_12>
    80000300:	01613823          	sd	s6,16(sp)
		(const struct uart_driver_api *)dev->api;

	if (api->poll_in == NULL) {
    80000304:	0104bb03          	ld	s6,16(s1)
    80000308:	03413023          	sd	s4,32(sp)
    8000030c:	00002a37          	lui	s4,0x2
    80000310:	03313423          	sd	s3,40(sp)
    80000314:	01513c23          	sd	s5,24(sp)
    80000318:	04113423          	sd	ra,72(sp)
    8000031c:	04813023          	sd	s0,64(sp)
    80000320:	03213823          	sd	s2,48(sp)
  while(1){
    
    //test uart , if recv a enter then , respond with the buf + hello
    if(uart_poll_in(dev, &ch)==0){
      
      rxbuf[idx%100] = ch;
    80000324:	00003997          	auipc	s3,0x3
    80000328:	f4098993          	addi	s3,s3,-192 # 80003264 <idx.0>
    8000032c:	00003a97          	auipc	s5,0x3
    80000330:	f4ca8a93          	addi	s5,s5,-180 # 80003278 <rxbuf>
    80000334:	f40a0a13          	addi	s4,s4,-192 # 1f40 <__kernel_ram_size+0x254>
    80000338:	000b3783          	ld	a5,0(s6)
    8000033c:	fe078ee3          	beqz	a5,80000338 <main+0x48>
		return -ENOSYS;
	}

	return api->poll_in(dev, p_char);
    80000340:	00f10593          	addi	a1,sp,15
    80000344:	00048513          	mv	a0,s1
    80000348:	000780e7          	jalr	a5
    8000034c:	00050413          	mv	s0,a0
    if(uart_poll_in(dev, &ch)==0){
    80000350:	fe0514e3          	bnez	a0,80000338 <main+0x48>
      rxbuf[idx%100] = ch;
    80000354:	0009a683          	lw	a3,0(s3)
    80000358:	06400793          	li	a5,100
    8000035c:	00f14703          	lbu	a4,15(sp)
    80000360:	02f6e7bb          	remw	a5,a3,a5
      
      if (idx < 100)
    80000364:	06300613          	li	a2,99
      rxbuf[idx%100] = ch;
    80000368:	00fa87b3          	add	a5,s5,a5
    8000036c:	00e78023          	sb	a4,0(a5)
        idx++;
      else
        idx = 0;
    80000370:	00000793          	li	a5,0
      if (idx < 100)
    80000374:	00d64463          	blt	a2,a3,8000037c <main+0x8c>
        idx++;
    80000378:	0016879b          	addiw	a5,a3,1
    8000037c:	00f9a023          	sw	a5,0(s3)
      
      
      if ((ch== 0x0d)||(ch==0x0a))  {
    80000380:	00d00793          	li	a5,13
    80000384:	00000913          	li	s2,0
    80000388:	00f70663          	beq	a4,a5,80000394 <main+0xa4>
    8000038c:	00a00793          	li	a5,10
    80000390:	faf714e3          	bne	a4,a5,80000338 <main+0x48>
        for (int i=0; i<(idx-1); i++){
    80000394:	0009a783          	lw	a5,0(s3)
    80000398:	0009071b          	sext.w	a4,s2
    8000039c:	fff7879b          	addiw	a5,a5,-1
    800003a0:	04f74263          	blt	a4,a5,800003e4 <main+0xf4>
          uart_poll_out(dev, rxbuf[i]);
        }
        idx = 0;
    800003a4:	00003797          	auipc	a5,0x3
    800003a8:	ec07a023          	sw	zero,-320(a5) # 80003264 <idx.0>
      
        for (int i = 0; i < strlen(poll_data); i++) {
    800003ac:	00003917          	auipc	s2,0x3
    800003b0:	cbc90913          	addi	s2,s2,-836 # 80003068 <_k_neg_eagain+0x8>
    800003b4:	00090513          	mv	a0,s2
    800003b8:	4e4010ef          	jal	ra,8000189c <strlen>
    800003bc:	04a46463          	bltu	s0,a0,80000404 <main+0x114>
    800003c0:	000a0793          	mv	a5,s4
          uart_poll_out(dev, poll_data[i]);
        }
      
        for (int i = 0; i<8000; i++){  //roughly 2 ms with 20MHz clk to bp core
          count ++;
    800003c4:	00003697          	auipc	a3,0x3
    800003c8:	e9c68693          	addi	a3,a3,-356 # 80003260 <count>
    800003cc:	0006a703          	lw	a4,0(a3)
        for (int i = 0; i<8000; i++){  //roughly 2 ms with 20MHz clk to bp core
    800003d0:	fff7879b          	addiw	a5,a5,-1
          count ++;
    800003d4:	0017071b          	addiw	a4,a4,1
    800003d8:	00e6a023          	sw	a4,0(a3)
        for (int i = 0; i<8000; i++){  //roughly 2 ms with 20MHz clk to bp core
    800003dc:	fe0798e3          	bnez	a5,800003cc <main+0xdc>
    800003e0:	f59ff06f          	j	80000338 <main+0x48>
          uart_poll_out(dev, rxbuf[i]);
    800003e4:	012a87b3          	add	a5,s5,s2
    800003e8:	0007c583          	lbu	a1,0(a5)
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
    800003ec:	0104b783          	ld	a5,16(s1)
    800003f0:	00048513          	mv	a0,s1
    800003f4:	00190913          	addi	s2,s2,1
    800003f8:	0087b783          	ld	a5,8(a5)
    800003fc:	000780e7          	jalr	a5
        for (int i=0; i<(idx-1); i++){
    80000400:	f95ff06f          	j	80000394 <main+0xa4>
          uart_poll_out(dev, poll_data[i]);
    80000404:	012407b3          	add	a5,s0,s2
    80000408:	0007c583          	lbu	a1,0(a5)
    8000040c:	0104b783          	ld	a5,16(s1)
    80000410:	00048513          	mv	a0,s1
        for (int i = 0; i < strlen(poll_data); i++) {
    80000414:	0014041b          	addiw	s0,s0,1
    80000418:	0087b783          	ld	a5,8(a5)
    8000041c:	000780e7          	jalr	a5
    80000420:	f95ff06f          	j	800003b4 <main+0xc4>

0000000080000424 <arch_printk_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
    80000424:	00000513          	li	a0,0
    80000428:	00008067          	ret

000000008000042c <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
    8000042c:	0005a783          	lw	a5,0(a1)
    80000430:	0017879b          	addiw	a5,a5,1
    80000434:	00f5a023          	sw	a5,0(a1)
	return _char_out(c);
    80000438:	00005797          	auipc	a5,0x5
    8000043c:	ae87b783          	ld	a5,-1304(a5) # 80004f20 <_char_out>
    80000440:	00078067          	jr	a5

0000000080000444 <vprintk>:
#endif
	}
}
#else
void vprintk(const char *fmt, va_list ap)
{
    80000444:	fe010113          	addi	sp,sp,-32
    80000448:	00050613          	mv	a2,a0
    8000044c:	00058693          	mv	a3,a1
	struct out_context ctx = { 0 };
#ifdef CONFIG_PRINTK_SYNC
	k_spinlock_key_t key = k_spin_lock(&lock);
#endif

	cbvprintf(char_out, &ctx, fmt, ap);
    80000450:	00000517          	auipc	a0,0x0
    80000454:	fdc50513          	addi	a0,a0,-36 # 8000042c <char_out>
    80000458:	00810593          	addi	a1,sp,8
{
    8000045c:	00113c23          	sd	ra,24(sp)
	struct out_context ctx = { 0 };
    80000460:	00012423          	sw	zero,8(sp)
	cbvprintf(char_out, &ctx, fmt, ap);
    80000464:	1ec000ef          	jal	ra,80000650 <cbvprintf>

#ifdef CONFIG_PRINTK_SYNC
	k_spin_unlock(&lock, key);
#endif
}
    80000468:	01813083          	ld	ra,24(sp)
    8000046c:	02010113          	addi	sp,sp,32
    80000470:	00008067          	ret

0000000080000474 <printk>:
 *
 * @return N/A
 */

void printk(const char *fmt, ...)
{
    80000474:	fa010113          	addi	sp,sp,-96
    80000478:	02b13423          	sd	a1,40(sp)
	va_list ap;

	va_start(ap, fmt);
    8000047c:	02810593          	addi	a1,sp,40
{
    80000480:	00113c23          	sd	ra,24(sp)
    80000484:	02c13823          	sd	a2,48(sp)
    80000488:	02d13c23          	sd	a3,56(sp)
    8000048c:	04e13023          	sd	a4,64(sp)
    80000490:	04f13423          	sd	a5,72(sp)
    80000494:	05013823          	sd	a6,80(sp)
    80000498:	05113c23          	sd	a7,88(sp)
	va_start(ap, fmt);
    8000049c:	00b13423          	sd	a1,8(sp)

	if (IS_ENABLED(CONFIG_LOG_PRINTK)) {
		log_printk(fmt, ap);
	} else {
		vprintk(fmt, ap);
    800004a0:	fa5ff0ef          	jal	ra,80000444 <vprintk>
	}
	va_end(ap);
}
    800004a4:	01813083          	ld	ra,24(sp)
    800004a8:	06010113          	addi	sp,sp,96
    800004ac:	00008067          	ret

00000000800004b0 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
    800004b0:	ff010113          	addi	sp,sp,-16
    800004b4:	00050793          	mv	a5,a0
    800004b8:	00058513          	mv	a0,a1
    800004bc:	00060593          	mv	a1,a2
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
    800004c0:	00068613          	mv	a2,a3
{
    800004c4:	00113423          	sd	ra,8(sp)
	entry(p1, p2, p3);
    800004c8:	000780e7          	jalr	a5
		/* coverity[OVERRUN] */
		return (k_tid_t) arch_syscall_invoke0(K_SYSCALL_Z_CURRENT_GET);
	}
#endif
	compiler_barrier();
	return z_impl_z_current_get();
    800004cc:	0f4020ef          	jal	ra,800025c0 <z_impl_z_current_get>
		arch_syscall_invoke1(*(uintptr_t *)&thread, K_SYSCALL_K_THREAD_ABORT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_thread_abort(thread);
    800004d0:	1f0020ef          	jal	ra,800026c0 <z_impl_k_thread_abort>

00000000800004d4 <_get_digit>:
 */
static char _get_digit(uint64_t *fr, int *digit_count)
{
	char rval;

	if (*digit_count > 0) {
    800004d4:	0005a783          	lw	a5,0(a1)
{
    800004d8:	00050693          	mv	a3,a0
	if (*digit_count > 0) {
    800004dc:	02f05a63          	blez	a5,80000510 <_get_digit+0x3c>
		--*digit_count;
		*fr *= 10U;
    800004e0:	00053703          	ld	a4,0(a0)
		--*digit_count;
    800004e4:	fff7879b          	addiw	a5,a5,-1
    800004e8:	00f5a023          	sw	a5,0(a1)
		*fr *= 10U;
    800004ec:	00a00793          	li	a5,10
    800004f0:	02e787b3          	mul	a5,a5,a4
		rval = ((*fr >> 60) & 0xF) + '0';
    800004f4:	03c7d713          	srli	a4,a5,0x3c
    800004f8:	03070513          	addi	a0,a4,48
		*fr &= (BIT64(60) - 1U);
    800004fc:	fff00713          	li	a4,-1
    80000500:	00475713          	srli	a4,a4,0x4
    80000504:	00e7f7b3          	and	a5,a5,a4
    80000508:	00f6b023          	sd	a5,0(a3)
    8000050c:	00008067          	ret
	} else {
		rval = '0';
    80000510:	03000513          	li	a0,48
	}

	return rval;
}
    80000514:	00008067          	ret

0000000080000518 <encode_uint>:
static char *encode_uint(uint_value_type value,
			 struct conversion *conv,
			 char *bps,
			 const char *bpe)
{
	bool upcase = isupper((int)conv->specifier);
    80000518:	0035c703          	lbu	a4,3(a1)
{
    8000051c:	00050813          	mv	a6,a0
    80000520:	00068513          	mv	a0,a3
	switch (specifier) {
    80000524:	06f00693          	li	a3,111
extern "C" {
#endif

static inline int isupper(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
    80000528:	fbf7089b          	addiw	a7,a4,-65
    8000052c:	00800793          	li	a5,8
    80000530:	00d70c63          	beq	a4,a3,80000548 <encode_uint+0x30>
    80000534:	06e6e263          	bltu	a3,a4,80000598 <encode_uint+0x80>
    80000538:	05800693          	li	a3,88
		return 10;
    8000053c:	00a00793          	li	a5,10
	switch (specifier) {
    80000540:	00d71463          	bne	a4,a3,80000548 <encode_uint+0x30>
		return 16;
    80000544:	01000793          	li	a5,16
	char *bp = bps + (bpe - bps);

	do {
		unsigned int lsv = (unsigned int)(value % radix);

		*--bp = (lsv <= 9) ? ('0' + lsv)
    80000548:	00900313          	li	t1,9
    8000054c:	01900e13          	li	t3,25
		unsigned int lsv = (unsigned int)(value % radix);
    80000550:	02f87733          	remu	a4,a6,a5
		*--bp = (lsv <= 9) ? ('0' + lsv)
    80000554:	0ff77693          	andi	a3,a4,255
    80000558:	04e36a63          	bltu	t1,a4,800005ac <encode_uint+0x94>
    8000055c:	03068713          	addi	a4,a3,48
    80000560:	fee50fa3          	sb	a4,-1(a0)
    80000564:	fff50513          	addi	a0,a0,-1
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
		value /= radix;
    80000568:	02f85733          	divu	a4,a6,a5
	} while ((value != 0) && (bps < bp));
    8000056c:	00f86463          	bltu	a6,a5,80000574 <encode_uint+0x5c>
    80000570:	02a66a63          	bltu	a2,a0,800005a4 <encode_uint+0x8c>

	/* Record required alternate forms.  This can be determined
	 * from the radix without re-checking specifier.
	 */
	if (conv->flag_hash) {
    80000574:	0005d703          	lhu	a4,0(a1)
    80000578:	02077713          	andi	a4,a4,32
    8000057c:	00070c63          	beqz	a4,80000594 <encode_uint+0x7c>
		if (radix == 8) {
    80000580:	00800713          	li	a4,8
    80000584:	02e79c63          	bne	a5,a4,800005bc <encode_uint+0xa4>
			conv->altform_0 = true;
    80000588:	0025c783          	lbu	a5,2(a1)
    8000058c:	0087e793          	ori	a5,a5,8
		} else if (radix == 16) {
			conv->altform_0c = true;
    80000590:	00f58123          	sb	a5,2(a1)
			;
		}
	}

	return bp;
}
    80000594:	00008067          	ret
	switch (specifier) {
    80000598:	0f777713          	andi	a4,a4,247
    8000059c:	07000693          	li	a3,112
    800005a0:	f9dff06f          	j	8000053c <encode_uint+0x24>
		value /= radix;
    800005a4:	00070813          	mv	a6,a4
    800005a8:	fa9ff06f          	j	80000550 <encode_uint+0x38>
		*--bp = (lsv <= 9) ? ('0' + lsv)
    800005ac:	05768713          	addi	a4,a3,87
    800005b0:	fb1e68e3          	bltu	t3,a7,80000560 <encode_uint+0x48>
    800005b4:	03768713          	addi	a4,a3,55
    800005b8:	fa9ff06f          	j	80000560 <encode_uint+0x48>
		} else if (radix == 16) {
    800005bc:	01000713          	li	a4,16
    800005c0:	fce79ae3          	bne	a5,a4,80000594 <encode_uint+0x7c>
			conv->altform_0c = true;
    800005c4:	0025c783          	lbu	a5,2(a1)
    800005c8:	0107e793          	ori	a5,a5,16
    800005cc:	fc5ff06f          	j	80000590 <encode_uint+0x78>

00000000800005d0 <outs>:
/* Outline function to emit all characters in [sp, ep). */
static int outs(cbprintf_cb out,
		void *ctx,
		const char *sp,
		const char *ep)
{
    800005d0:	fd010113          	addi	sp,sp,-48
    800005d4:	02813023          	sd	s0,32(sp)
    800005d8:	00913c23          	sd	s1,24(sp)
    800005dc:	01213823          	sd	s2,16(sp)
    800005e0:	01313423          	sd	s3,8(sp)
    800005e4:	01413023          	sd	s4,0(sp)
    800005e8:	02113423          	sd	ra,40(sp)
    800005ec:	00050993          	mv	s3,a0
    800005f0:	00058a13          	mv	s4,a1
    800005f4:	00060493          	mv	s1,a2
    800005f8:	00068913          	mv	s2,a3
	size_t count = 0;

	while ((sp < ep) || ((ep == NULL) && *sp)) {
    800005fc:	00060413          	mv	s0,a2
    80000600:	409407b3          	sub	a5,s0,s1
    80000604:	01246c63          	bltu	s0,s2,8000061c <outs+0x4c>
    80000608:	00090663          	beqz	s2,80000614 <outs+0x44>
			return rc;
		}
		++count;
	}

	return (int)count;
    8000060c:	0007851b          	sext.w	a0,a5
    80000610:	0200006f          	j	80000630 <outs+0x60>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
    80000614:	00044703          	lbu	a4,0(s0)
    80000618:	fe070ae3          	beqz	a4,8000060c <outs+0x3c>
		int rc = out((int)*sp++, ctx);
    8000061c:	00044503          	lbu	a0,0(s0)
    80000620:	000a0593          	mv	a1,s4
    80000624:	00140413          	addi	s0,s0,1
    80000628:	000980e7          	jalr	s3
		if (rc < 0) {
    8000062c:	fc055ae3          	bgez	a0,80000600 <outs+0x30>
}
    80000630:	02813083          	ld	ra,40(sp)
    80000634:	02013403          	ld	s0,32(sp)
    80000638:	01813483          	ld	s1,24(sp)
    8000063c:	01013903          	ld	s2,16(sp)
    80000640:	00813983          	ld	s3,8(sp)
    80000644:	00013a03          	ld	s4,0(sp)
    80000648:	03010113          	addi	sp,sp,48
    8000064c:	00008067          	ret

0000000080000650 <cbvprintf>:

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
    80000650:	f3010113          	addi	sp,sp,-208
    80000654:	09813023          	sd	s8,128(sp)
		} while ((uint32_t)(fract >> 32) >= (UINT32_MAX / 5U));
    80000658:	33333c37          	lui	s8,0x33333
    8000065c:	332c0793          	addi	a5,s8,818 # 33333332 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x32020632>
{
    80000660:	0c813023          	sd	s0,192(sp)
    80000664:	0a913c23          	sd	s1,184(sp)
    80000668:	0b213823          	sd	s2,176(sp)
    8000066c:	0b413023          	sd	s4,160(sp)
    80000670:	09613823          	sd	s6,144(sp)
    80000674:	0c113423          	sd	ra,200(sp)
    80000678:	0b313423          	sd	s3,168(sp)
    8000067c:	09513c23          	sd	s5,152(sp)
    80000680:	09713423          	sd	s7,136(sp)
    80000684:	07913c23          	sd	s9,120(sp)
    80000688:	07a13823          	sd	s10,112(sp)
    8000068c:	07b13423          	sd	s11,104(sp)
    80000690:	00050493          	mv	s1,a0
    80000694:	00058913          	mv	s2,a1
    80000698:	00068a13          	mv	s4,a3
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
    8000069c:	00000413          	li	s0,0
		/* Extract the value based on the argument category and length.
		 *
		 * Note that the length modifier doesn't affect the value of a
		 * pointer argument.
		 */
		if (specifier_cat == SPECIFIER_SINT) {
    800006a0:	00100b13          	li	s6,1
		} while ((uint32_t)(fract >> 32) >= (UINT32_MAX / 5U));
    800006a4:	00f13423          	sd	a5,8(sp)
	while (*fp != 0) {
    800006a8:	00064503          	lbu	a0,0(a2)
    800006ac:	00051663          	bnez	a0,800006b8 <cbvprintf+0x68>
			OUTC(' ');
			--width;
		}
	}

	return count;
    800006b0:	0004051b          	sext.w	a0,s0
    800006b4:	6d50006f          	j	80001588 <cbvprintf+0xf38>
		if (*fp != '%') {
    800006b8:	02500793          	li	a5,37
			OUTC(*fp++);
    800006bc:	00160a93          	addi	s5,a2,1
    800006c0:	00090593          	mv	a1,s2
		if (*fp != '%') {
    800006c4:	02f514e3          	bne	a0,a5,80000eec <cbvprintf+0x89c>
	if (*sp == '%') {
    800006c8:	00164783          	lbu	a5,1(a2)
		} state = {
    800006cc:	04013023          	sd	zero,64(sp)
    800006d0:	04013423          	sd	zero,72(sp)
    800006d4:	04013823          	sd	zero,80(sp)
    800006d8:	04013c23          	sd	zero,88(sp)
	if (*sp == '%') {
    800006dc:	04a79c63          	bne	a5,a0,80000734 <cbvprintf+0xe4>
		conv->specifier = *sp++;
    800006e0:	00260a93          	addi	s5,a2,2
    800006e4:	04f109a3          	sb	a5,83(sp)
		if (conv->width_star) {
    800006e8:	05015783          	lhu	a5,80(sp)
    800006ec:	1007f713          	andi	a4,a5,256
    800006f0:	52070863          	beqz	a4,80000c20 <cbvprintf+0x5d0>
			width = va_arg(ap, int);
    800006f4:	000a2983          	lw	s3,0(s4)
    800006f8:	008a0593          	addi	a1,s4,8
			if (width < 0) {
    800006fc:	0009d863          	bgez	s3,8000070c <cbvprintf+0xbc>
				conv->flag_dash = true;
    80000700:	0047e793          	ori	a5,a5,4
    80000704:	04f11823          	sh	a5,80(sp)
				width = -width;
    80000708:	413009bb          	negw	s3,s3
		if (conv->prec_star) {
    8000070c:	05015683          	lhu	a3,80(sp)
    80000710:	4006f793          	andi	a5,a3,1024
    80000714:	52078663          	beqz	a5,80000c40 <cbvprintf+0x5f0>
			int arg = va_arg(ap, int);
    80000718:	0005ab83          	lw	s7,0(a1)
    8000071c:	00858793          	addi	a5,a1,8
			if (arg < 0) {
    80000720:	520bd863          	bgez	s7,80000c50 <cbvprintf+0x600>
				conv->prec_present = false;
    80000724:	dff6f693          	andi	a3,a3,-513
    80000728:	04d11823          	sh	a3,80(sp)
		int precision = -1;
    8000072c:	fff00b93          	li	s7,-1
    80000730:	5200006f          	j	80000c50 <cbvprintf+0x600>
    80000734:	00000693          	li	a3,0
    80000738:	00000813          	li	a6,0
    8000073c:	00000513          	li	a0,0
    80000740:	00000593          	li	a1,0
    80000744:	00000793          	li	a5,0
		switch (*sp) {
    80000748:	02b00893          	li	a7,43
    8000074c:	02d00313          	li	t1,45
    80000750:	03000e13          	li	t3,48
    80000754:	02000e93          	li	t4,32
    80000758:	02300f13          	li	t5,35
    8000075c:	000ac703          	lbu	a4,0(s5)
    80000760:	15170063          	beq	a4,a7,800008a0 <cbvprintf+0x250>
    80000764:	12e8e663          	bltu	a7,a4,80000890 <cbvprintf+0x240>
    80000768:	15d70263          	beq	a4,t4,800008ac <cbvprintf+0x25c>
    8000076c:	15e70463          	beq	a4,t5,800008b4 <cbvprintf+0x264>
    80000770:	00078863          	beqz	a5,80000780 <cbvprintf+0x130>
    80000774:	05015783          	lhu	a5,80(sp)
    80000778:	0047e793          	ori	a5,a5,4
    8000077c:	04f11823          	sh	a5,80(sp)
    80000780:	00058863          	beqz	a1,80000790 <cbvprintf+0x140>
    80000784:	05015783          	lhu	a5,80(sp)
    80000788:	0087e793          	ori	a5,a5,8
    8000078c:	04f11823          	sh	a5,80(sp)
    80000790:	00050863          	beqz	a0,800007a0 <cbvprintf+0x150>
    80000794:	05015783          	lhu	a5,80(sp)
    80000798:	0107e793          	ori	a5,a5,16
    8000079c:	04f11823          	sh	a5,80(sp)
    800007a0:	00080863          	beqz	a6,800007b0 <cbvprintf+0x160>
    800007a4:	05015783          	lhu	a5,80(sp)
    800007a8:	0207e793          	ori	a5,a5,32
    800007ac:	04f11823          	sh	a5,80(sp)
    800007b0:	00068863          	beqz	a3,800007c0 <cbvprintf+0x170>
    800007b4:	05015783          	lhu	a5,80(sp)
    800007b8:	0407e793          	ori	a5,a5,64
    800007bc:	04f11823          	sh	a5,80(sp)
	if (conv->flag_zero && conv->flag_dash) {
    800007c0:	05012783          	lw	a5,80(sp)
    800007c4:	04400693          	li	a3,68
    800007c8:	0447f793          	andi	a5,a5,68
    800007cc:	00d79863          	bne	a5,a3,800007dc <cbvprintf+0x18c>
		conv->flag_zero = false;
    800007d0:	05015783          	lhu	a5,80(sp)
    800007d4:	fbf7f793          	andi	a5,a5,-65
    800007d8:	04f11823          	sh	a5,80(sp)
	conv->width_present = true;
    800007dc:	05015783          	lhu	a5,80(sp)
    800007e0:	0807e693          	ori	a3,a5,128
    800007e4:	04d11823          	sh	a3,80(sp)
	if (*sp == '*') {
    800007e8:	02a00693          	li	a3,42
    800007ec:	12d71463          	bne	a4,a3,80000914 <cbvprintf+0x2c4>
			++sp;
    800007f0:	001a8593          	addi	a1,s5,1
		conv->width_star = true;
    800007f4:	1807e793          	ori	a5,a5,384
		conv->unsupported |= ((conv->width_value < 0)
    800007f8:	04f11823          	sh	a5,80(sp)
	conv->prec_present = (*sp == '.');
    800007fc:	0005c683          	lbu	a3,0(a1)
    80000800:	02e00513          	li	a0,46
    80000804:	fd268793          	addi	a5,a3,-46
    80000808:	0017b793          	seqz	a5,a5
    8000080c:	0097971b          	slliw	a4,a5,0x9
    80000810:	05015783          	lhu	a5,80(sp)
    80000814:	dff7f793          	andi	a5,a5,-513
    80000818:	00e7e7b3          	or	a5,a5,a4
    8000081c:	04f11823          	sh	a5,80(sp)
	if (!conv->prec_present) {
    80000820:	10a69a63          	bne	a3,a0,80000934 <cbvprintf+0x2e4>
	if (*sp == '*') {
    80000824:	0015c683          	lbu	a3,1(a1)
    80000828:	02a00713          	li	a4,42
    8000082c:	0ee68e63          	beq	a3,a4,80000928 <cbvprintf+0x2d8>
	++sp;
    80000830:	00158593          	addi	a1,a1,1
	size_t val = 0;
    80000834:	00000713          	li	a4,0
	while (isdigit((int)(unsigned char)*sp)) {
    80000838:	00900693          	li	a3,9
		val = 10U * val + *sp++ - '0';
    8000083c:	00a00893          	li	a7,10
	while (isdigit((int)(unsigned char)*sp)) {
    80000840:	0005c783          	lbu	a5,0(a1)
		val = 10U * val + *sp++ - '0';
    80000844:	00158813          	addi	a6,a1,1
	while (isdigit((int)(unsigned char)*sp)) {
    80000848:	fd07851b          	addiw	a0,a5,-48
    8000084c:	1ca6f063          	bgeu	a3,a0,80000a0c <cbvprintf+0x3bc>
	conv->unsupported |= ((conv->prec_value < 0)
    80000850:	05013783          	ld	a5,80(sp)
	conv->prec_value = prec;
    80000854:	0007069b          	sext.w	a3,a4
    80000858:	04d12c23          	sw	a3,88(sp)
	conv->unsupported |= ((conv->prec_value < 0)
    8000085c:	0017d793          	srli	a5,a5,0x1
    80000860:	0017f793          	andi	a5,a5,1
			      || (prec != (size_t)conv->prec_value));
    80000864:	00100513          	li	a0,1
    80000868:	0006c663          	bltz	a3,80000874 <cbvprintf+0x224>
    8000086c:	40e68733          	sub	a4,a3,a4
    80000870:	00e03533          	snez	a0,a4
	conv->unsupported |= ((conv->prec_value < 0)
    80000874:	05015703          	lhu	a4,80(sp)
    80000878:	00a7e7b3          	or	a5,a5,a0
    8000087c:	0017979b          	slliw	a5,a5,0x1
    80000880:	ffd77713          	andi	a4,a4,-3
    80000884:	00f767b3          	or	a5,a4,a5
    80000888:	04f11823          	sh	a5,80(sp)
	return sp;
    8000088c:	0a80006f          	j	80000934 <cbvprintf+0x2e4>
		switch (*sp) {
    80000890:	02670663          	beq	a4,t1,800008bc <cbvprintf+0x26c>
    80000894:	edc71ee3          	bne	a4,t3,80000770 <cbvprintf+0x120>
			conv->flag_zero = true;
    80000898:	00100693          	li	a3,1
    8000089c:	0080006f          	j	800008a4 <cbvprintf+0x254>
			conv->flag_plus = true;
    800008a0:	00100593          	li	a1,1
			++sp;
    800008a4:	001a8a93          	addi	s5,s5,1
	} while (loop);
    800008a8:	eb5ff06f          	j	8000075c <cbvprintf+0x10c>
			conv->flag_space = true;
    800008ac:	00100513          	li	a0,1
    800008b0:	ff5ff06f          	j	800008a4 <cbvprintf+0x254>
			conv->flag_hash = true;
    800008b4:	00100813          	li	a6,1
    800008b8:	fedff06f          	j	800008a4 <cbvprintf+0x254>
		switch (*sp) {
    800008bc:	00100793          	li	a5,1
    800008c0:	fe5ff06f          	j	800008a4 <cbvprintf+0x254>
		val = 10U * val + *sp++ - '0';
    800008c4:	031787b3          	mul	a5,a5,a7
    800008c8:	00080593          	mv	a1,a6
    800008cc:	fd078793          	addi	a5,a5,-48
    800008d0:	00f707b3          	add	a5,a4,a5
	while (isdigit((int)(unsigned char)*sp)) {
    800008d4:	0005c703          	lbu	a4,0(a1)
		val = 10U * val + *sp++ - '0';
    800008d8:	00158813          	addi	a6,a1,1
	while (isdigit((int)(unsigned char)*sp)) {
    800008dc:	fd07051b          	addiw	a0,a4,-48
    800008e0:	fea6f2e3          	bgeu	a3,a0,800008c4 <cbvprintf+0x274>
	if (sp != wp) {
    800008e4:	f0ba8ce3          	beq	s5,a1,800007fc <cbvprintf+0x1ac>
		conv->width_value = width;
    800008e8:	0007871b          	sext.w	a4,a5
    800008ec:	04e12a23          	sw	a4,84(sp)
				      || (width != (size_t)conv->width_value));
    800008f0:	00100693          	li	a3,1
    800008f4:	00074663          	bltz	a4,80000900 <cbvprintf+0x2b0>
    800008f8:	40f707b3          	sub	a5,a4,a5
    800008fc:	00f036b3          	snez	a3,a5
		conv->unsupported |= ((conv->width_value < 0)
    80000900:	05015783          	lhu	a5,80(sp)
    80000904:	0016969b          	slliw	a3,a3,0x1
    80000908:	ffd7f793          	andi	a5,a5,-3
    8000090c:	00d7e7b3          	or	a5,a5,a3
    80000910:	ee9ff06f          	j	800007f8 <cbvprintf+0x1a8>
    80000914:	000a8593          	mv	a1,s5
	size_t val = 0;
    80000918:	00000793          	li	a5,0
	while (isdigit((int)(unsigned char)*sp)) {
    8000091c:	00900693          	li	a3,9
		val = 10U * val + *sp++ - '0';
    80000920:	00a00893          	li	a7,10
    80000924:	fb1ff06f          	j	800008d4 <cbvprintf+0x284>
		conv->prec_star = true;
    80000928:	4007e793          	ori	a5,a5,1024
    8000092c:	04f11823          	sh	a5,80(sp)
		return ++sp;
    80000930:	00258593          	addi	a1,a1,2
	switch (*sp) {
    80000934:	0005c683          	lbu	a3,0(a1)
    80000938:	06c00793          	li	a5,108
		if (*++sp == 'h') {
    8000093c:	00158513          	addi	a0,a1,1
	switch (*sp) {
    80000940:	14f68263          	beq	a3,a5,80000a84 <cbvprintf+0x434>
    80000944:	0cd7ee63          	bltu	a5,a3,80000a20 <cbvprintf+0x3d0>
    80000948:	06800793          	li	a5,104
    8000094c:	10f68263          	beq	a3,a5,80000a50 <cbvprintf+0x400>
    80000950:	06a00793          	li	a5,106
    80000954:	14f68a63          	beq	a3,a5,80000aa8 <cbvprintf+0x458>
    80000958:	04c00793          	li	a5,76
    8000095c:	18f68063          	beq	a3,a5,80000adc <cbvprintf+0x48c>
    80000960:	00058513          	mv	a0,a1
	conv->specifier = *sp++;
    80000964:	00054783          	lbu	a5,0(a0)
	switch (conv->specifier) {
    80000968:	07800713          	li	a4,120
	conv->specifier = *sp++;
    8000096c:	00150a93          	addi	s5,a0,1
    80000970:	04f109a3          	sb	a5,83(sp)
	switch (conv->specifier) {
    80000974:	28f76e63          	bltu	a4,a5,80000c10 <cbvprintf+0x5c0>
    80000978:	05700713          	li	a4,87
    8000097c:	16f76e63          	bltu	a4,a5,80000af8 <cbvprintf+0x4a8>
    80000980:	04100713          	li	a4,65
    80000984:	00e78a63          	beq	a5,a4,80000998 <cbvprintf+0x348>
    80000988:	fbb7871b          	addiw	a4,a5,-69
    8000098c:	0ff77713          	andi	a4,a4,255
    80000990:	00200693          	li	a3,2
    80000994:	26e6ee63          	bltu	a3,a4,80000c10 <cbvprintf+0x5c0>
		conv->specifier_cat = SPECIFIER_FP;
    80000998:	05214703          	lbu	a4,82(sp)
		conv->specifier_a = (conv->specifier == 'a')
    8000099c:	05015683          	lhu	a3,80(sp)
			|| (conv->specifier == 'A');
    800009a0:	0df7f793          	andi	a5,a5,223
		conv->specifier_cat = SPECIFIER_FP;
    800009a4:	ff877713          	andi	a4,a4,-8
    800009a8:	00476713          	ori	a4,a4,4
			|| (conv->specifier == 'A');
    800009ac:	fbf78793          	addi	a5,a5,-65
		conv->specifier_a = (conv->specifier == 'a')
    800009b0:	000085b7          	lui	a1,0x8
		conv->specifier_cat = SPECIFIER_FP;
    800009b4:	04e10923          	sb	a4,82(sp)
			|| (conv->specifier == 'A');
    800009b8:	0017b793          	seqz	a5,a5
		conv->specifier_a = (conv->specifier == 'a')
    800009bc:	fff58713          	addi	a4,a1,-1 # 7fff <__rom_region_size+0x4db7>
    800009c0:	00f7979b          	slliw	a5,a5,0xf
    800009c4:	00e6f6b3          	and	a3,a3,a4
    800009c8:	00f6e6b3          	or	a3,a3,a5
		if (conv->specifier_a
    800009cc:	03069713          	slli	a4,a3,0x30
		conv->specifier_a = (conv->specifier == 'a')
    800009d0:	04d11823          	sh	a3,80(sp)
		if (conv->specifier_a
    800009d4:	03069513          	slli	a0,a3,0x30
    800009d8:	03075713          	srli	a4,a4,0x30
			unsupported = true;
    800009dc:	00100793          	li	a5,1
		if (conv->specifier_a
    800009e0:	1e054063          	bltz	a0,80000bc0 <cbvprintf+0x570>
		if (conv->length_mod == LENGTH_L) {
    800009e4:	80058593          	addi	a1,a1,-2048
    800009e8:	000027b7          	lui	a5,0x2
    800009ec:	00b775b3          	and	a1,a4,a1
    800009f0:	80078793          	addi	a5,a5,-2048 # 1800 <CONFIG_MAIN_STACK_SIZE+0x800>
    800009f4:	18f59463          	bne	a1,a5,80000b7c <cbvprintf+0x52c>
			conv->length_mod = LENGTH_NONE;
    800009f8:	ffff87b7          	lui	a5,0xffff8
    800009fc:	7ff78793          	addi	a5,a5,2047 # ffffffffffff87ff <__data_region_end+0xffffffff7fff38cb>
    80000a00:	00f77733          	and	a4,a4,a5
			conv->invalid = true;
    80000a04:	04e11823          	sh	a4,80(sp)
    80000a08:	15c0006f          	j	80000b64 <cbvprintf+0x514>
		val = 10U * val + *sp++ - '0';
    80000a0c:	03170733          	mul	a4,a4,a7
    80000a10:	00080593          	mv	a1,a6
    80000a14:	fd070713          	addi	a4,a4,-48
    80000a18:	00e78733          	add	a4,a5,a4
    80000a1c:	e25ff06f          	j	80000840 <cbvprintf+0x1f0>
	switch (*sp) {
    80000a20:	07400793          	li	a5,116
    80000a24:	0af68063          	beq	a3,a5,80000ac4 <cbvprintf+0x474>
    80000a28:	07a00793          	li	a5,122
    80000a2c:	f2f69ae3          	bne	a3,a5,80000960 <cbvprintf+0x310>
		conv->length_mod = LENGTH_Z;
    80000a30:	05015783          	lhu	a5,80(sp)
    80000a34:	ffff8737          	lui	a4,0xffff8
    80000a38:	7ff70713          	addi	a4,a4,2047 # ffffffffffff87ff <__data_region_end+0xffffffff7fff38cb>
    80000a3c:	00e7f7b3          	and	a5,a5,a4
    80000a40:	00003737          	lui	a4,0x3
		conv->unsupported = true;
    80000a44:	00e7e7b3          	or	a5,a5,a4
    80000a48:	04f11823          	sh	a5,80(sp)
		break;
    80000a4c:	f19ff06f          	j	80000964 <cbvprintf+0x314>
		if (*++sp == 'h') {
    80000a50:	05015803          	lhu	a6,80(sp)
    80000a54:	0015c883          	lbu	a7,1(a1)
    80000a58:	ffff8737          	lui	a4,0xffff8
    80000a5c:	7ff70793          	addi	a5,a4,2047 # ffffffffffff87ff <__data_region_end+0xffffffff7fff38cb>
			conv->length_mod = LENGTH_HH;
    80000a60:	0107f7b3          	and	a5,a5,a6
			conv->length_mod = LENGTH_H;
    80000a64:	00001737          	lui	a4,0x1
		if (*++sp == 'h') {
    80000a68:	fcd89ee3          	bne	a7,a3,80000a44 <cbvprintf+0x3f4>
			conv->length_mod = LENGTH_HH;
    80000a6c:	00001737          	lui	a4,0x1
    80000a70:	80070713          	addi	a4,a4,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
			conv->length_mod = LENGTH_LL;
    80000a74:	00e7e7b3          	or	a5,a5,a4
    80000a78:	04f11823          	sh	a5,80(sp)
			++sp;
    80000a7c:	00258513          	addi	a0,a1,2
    80000a80:	ee5ff06f          	j	80000964 <cbvprintf+0x314>
		if (*++sp == 'l') {
    80000a84:	05015803          	lhu	a6,80(sp)
    80000a88:	0015c883          	lbu	a7,1(a1)
    80000a8c:	ffff8737          	lui	a4,0xffff8
    80000a90:	7ff70793          	addi	a5,a4,2047 # ffffffffffff87ff <__data_region_end+0xffffffff7fff38cb>
			conv->length_mod = LENGTH_LL;
    80000a94:	0107f7b3          	and	a5,a5,a6
			conv->length_mod = LENGTH_L;
    80000a98:	00002737          	lui	a4,0x2
		if (*++sp == 'l') {
    80000a9c:	02d89063          	bne	a7,a3,80000abc <cbvprintf+0x46c>
			conv->length_mod = LENGTH_LL;
    80000aa0:	00002737          	lui	a4,0x2
    80000aa4:	fd1ff06f          	j	80000a74 <cbvprintf+0x424>
		conv->length_mod = LENGTH_J;
    80000aa8:	05015783          	lhu	a5,80(sp)
    80000aac:	ffff8737          	lui	a4,0xffff8
    80000ab0:	7ff70713          	addi	a4,a4,2047 # ffffffffffff87ff <__data_region_end+0xffffffff7fff38cb>
    80000ab4:	00e7f7b3          	and	a5,a5,a4
    80000ab8:	00003737          	lui	a4,0x3
		conv->length_mod = LENGTH_T;
    80000abc:	80070713          	addi	a4,a4,-2048 # 2800 <CONFIG_SYS_CLOCK_TICKS_PER_SEC+0xf0>
    80000ac0:	f85ff06f          	j	80000a44 <cbvprintf+0x3f4>
    80000ac4:	05015783          	lhu	a5,80(sp)
    80000ac8:	ffff8737          	lui	a4,0xffff8
    80000acc:	7ff70713          	addi	a4,a4,2047 # ffffffffffff87ff <__data_region_end+0xffffffff7fff38cb>
    80000ad0:	00e7f7b3          	and	a5,a5,a4
    80000ad4:	00004737          	lui	a4,0x4
    80000ad8:	fe5ff06f          	j	80000abc <cbvprintf+0x46c>
		conv->unsupported = true;
    80000adc:	05015783          	lhu	a5,80(sp)
    80000ae0:	ffff8737          	lui	a4,0xffff8
    80000ae4:	7fd70713          	addi	a4,a4,2045 # ffffffffffff87fd <__data_region_end+0xffffffff7fff38c9>
    80000ae8:	00e7f7b3          	and	a5,a5,a4
    80000aec:	00004737          	lui	a4,0x4
    80000af0:	00270713          	addi	a4,a4,2 # 4002 <__rom_region_size+0xdba>
    80000af4:	f51ff06f          	j	80000a44 <cbvprintf+0x3f4>
	switch (conv->specifier) {
    80000af8:	fa87871b          	addiw	a4,a5,-88
    80000afc:	0ff77713          	andi	a4,a4,255
    80000b00:	02000693          	li	a3,32
    80000b04:	10e6e663          	bltu	a3,a4,80000c10 <cbvprintf+0x5c0>
    80000b08:	00002697          	auipc	a3,0x2
    80000b0c:	61868693          	addi	a3,a3,1560 # 80003120 <levels.0+0x28>
    80000b10:	00271713          	slli	a4,a4,0x2
    80000b14:	00d70733          	add	a4,a4,a3
    80000b18:	00072703          	lw	a4,0(a4)
    80000b1c:	00d70733          	add	a4,a4,a3
    80000b20:	00070067          	jr	a4
		conv->specifier_cat = SPECIFIER_SINT;
    80000b24:	05214703          	lbu	a4,82(sp)
    80000b28:	ff877713          	andi	a4,a4,-8
    80000b2c:	00176713          	ori	a4,a4,1
		if (conv->length_mod == LENGTH_UPPER_L) {
    80000b30:	05015683          	lhu	a3,80(sp)
		conv->specifier_cat = SPECIFIER_UINT;
    80000b34:	04e10923          	sb	a4,82(sp)
		if (conv->length_mod == LENGTH_UPPER_L) {
    80000b38:	00008737          	lui	a4,0x8
    80000b3c:	80070713          	addi	a4,a4,-2048 # 7800 <__rom_region_size+0x45b8>
    80000b40:	00e6f733          	and	a4,a3,a4
    80000b44:	0107171b          	slliw	a4,a4,0x10
    80000b48:	0107571b          	srliw	a4,a4,0x10
    80000b4c:	000045b7          	lui	a1,0x4
    80000b50:	00b71663          	bne	a4,a1,80000b5c <cbvprintf+0x50c>
			conv->invalid = true;
    80000b54:	0016e693          	ori	a3,a3,1
    80000b58:	04d11823          	sh	a3,80(sp)
		if (conv->specifier == 'c') {
    80000b5c:	06300713          	li	a4,99
    80000b60:	08e78c63          	beq	a5,a4,80000bf8 <cbvprintf+0x5a8>
	bool unsupported = false;
    80000b64:	00000793          	li	a5,0
		break;
    80000b68:	0580006f          	j	80000bc0 <cbvprintf+0x570>
		conv->specifier_cat = SPECIFIER_UINT;
    80000b6c:	05214703          	lbu	a4,82(sp)
    80000b70:	ff877713          	andi	a4,a4,-8
    80000b74:	00276713          	ori	a4,a4,2
    80000b78:	fb9ff06f          	j	80000b30 <cbvprintf+0x4e0>
		} else if ((conv->length_mod != LENGTH_NONE)
    80000b7c:	000047b7          	lui	a5,0x4
    80000b80:	80078793          	addi	a5,a5,-2048 # 3800 <__rom_region_size+0x5b8>
    80000b84:	00f777b3          	and	a5,a4,a5
    80000b88:	fc078ee3          	beqz	a5,80000b64 <cbvprintf+0x514>
			conv->invalid = true;
    80000b8c:	00176713          	ori	a4,a4,1
    80000b90:	e75ff06f          	j	80000a04 <cbvprintf+0x3b4>
		conv->specifier_cat = SPECIFIER_PTR;
    80000b94:	05214783          	lbu	a5,82(sp)
		if (conv->length_mod == LENGTH_UPPER_L) {
    80000b98:	05015703          	lhu	a4,80(sp)
		conv->specifier_cat = SPECIFIER_PTR;
    80000b9c:	ff87f793          	andi	a5,a5,-8
    80000ba0:	0037e793          	ori	a5,a5,3
    80000ba4:	04f10923          	sb	a5,82(sp)
		if (conv->length_mod == LENGTH_UPPER_L) {
    80000ba8:	000087b7          	lui	a5,0x8
    80000bac:	80078793          	addi	a5,a5,-2048 # 7800 <__rom_region_size+0x45b8>
    80000bb0:	00e7f7b3          	and	a5,a5,a4
    80000bb4:	00004737          	lui	a4,0x4
    80000bb8:	40e787b3          	sub	a5,a5,a4
    80000bbc:	0017b793          	seqz	a5,a5
	conv->unsupported |= unsupported;
    80000bc0:	05013703          	ld	a4,80(sp)
    80000bc4:	00175713          	srli	a4,a4,0x1
    80000bc8:	00177713          	andi	a4,a4,1
    80000bcc:	00e7e7b3          	or	a5,a5,a4
    80000bd0:	05015703          	lhu	a4,80(sp)
    80000bd4:	0017979b          	slliw	a5,a5,0x1
    80000bd8:	ffd77713          	andi	a4,a4,-3
    80000bdc:	00f767b3          	or	a5,a4,a5
    80000be0:	04f11823          	sh	a5,80(sp)
	return sp;
    80000be4:	b05ff06f          	j	800006e8 <cbvprintf+0x98>
		conv->specifier_cat = SPECIFIER_PTR;
    80000be8:	05214783          	lbu	a5,82(sp)
    80000bec:	ff87f793          	andi	a5,a5,-8
    80000bf0:	0037e793          	ori	a5,a5,3
    80000bf4:	04f10923          	sb	a5,82(sp)
		if (conv->length_mod != LENGTH_NONE) {
    80000bf8:	05015703          	lhu	a4,80(sp)
    80000bfc:	000087b7          	lui	a5,0x8
    80000c00:	80078793          	addi	a5,a5,-2048 # 7800 <__rom_region_size+0x45b8>
    80000c04:	00e7f7b3          	and	a5,a5,a4
    80000c08:	00f037b3          	snez	a5,a5
    80000c0c:	fb5ff06f          	j	80000bc0 <cbvprintf+0x570>
		conv->invalid = true;
    80000c10:	05015783          	lhu	a5,80(sp)
    80000c14:	0017e793          	ori	a5,a5,1
    80000c18:	04f11823          	sh	a5,80(sp)
    80000c1c:	f49ff06f          	j	80000b64 <cbvprintf+0x514>
		} else if (conv->width_present) {
    80000c20:	0807f793          	andi	a5,a5,128
    80000c24:	00078863          	beqz	a5,80000c34 <cbvprintf+0x5e4>
			width = conv->width_value;
    80000c28:	05412983          	lw	s3,84(sp)
    80000c2c:	000a0593          	mv	a1,s4
    80000c30:	addff06f          	j	8000070c <cbvprintf+0xbc>
    80000c34:	000a0593          	mv	a1,s4
		int width = -1;
    80000c38:	fff00993          	li	s3,-1
    80000c3c:	ad1ff06f          	j	8000070c <cbvprintf+0xbc>
		} else if (conv->prec_present) {
    80000c40:	2006f693          	andi	a3,a3,512
    80000c44:	08068863          	beqz	a3,80000cd4 <cbvprintf+0x684>
			precision = conv->prec_value;
    80000c48:	05812b83          	lw	s7,88(sp)
    80000c4c:	00058793          	mv	a5,a1
		    && (conv->specifier_cat == SPECIFIER_FP)
    80000c50:	05214683          	lbu	a3,82(sp)
		conv->pad0_value = 0;
    80000c54:	04012a23          	sw	zero,84(sp)
		conv->pad0_pre_exp = 0;
    80000c58:	04012c23          	sw	zero,88(sp)
		if (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT)
    80000c5c:	0076f693          	andi	a3,a3,7
    80000c60:	00400593          	li	a1,4
    80000c64:	05013503          	ld	a0,80(sp)
    80000c68:	02b69063          	bne	a3,a1,80000c88 <cbvprintf+0x638>
		    && !conv->prec_present) {
    80000c6c:	00955693          	srli	a3,a0,0x9
    80000c70:	0016f693          	andi	a3,a3,1
    80000c74:	00069a63          	bnez	a3,80000c88 <cbvprintf+0x638>
			if (conv->specifier_a) {
    80000c78:	05011683          	lh	a3,80(sp)
				precision = FRACTION_HEX;
    80000c7c:	00d00b93          	li	s7,13
			if (conv->specifier_a) {
    80000c80:	0006c463          	bltz	a3,80000c88 <cbvprintf+0x638>
				precision = 6;
    80000c84:	00600b93          	li	s7,6
			= (enum length_mod_enum)conv->length_mod;
    80000c88:	00b55693          	srli	a3,a0,0xb
			= (enum specifier_cat_enum)conv->specifier_cat;
    80000c8c:	01055593          	srli	a1,a0,0x10
			= (enum length_mod_enum)conv->length_mod;
    80000c90:	00f6f813          	andi	a6,a3,15
		enum specifier_cat_enum specifier_cat
    80000c94:	0075f593          	andi	a1,a1,7
		enum length_mod_enum length_mod
    80000c98:	00080693          	mv	a3,a6
		if (specifier_cat == SPECIFIER_SINT) {
    80000c9c:	07659463          	bne	a1,s6,80000d04 <cbvprintf+0x6b4>
			switch (length_mod) {
    80000ca0:	00500593          	li	a1,5
				value->sint = va_arg(ap, int);
    80000ca4:	00878a13          	addi	s4,a5,8
			switch (length_mod) {
    80000ca8:	14b80063          	beq	a6,a1,80000de8 <cbvprintf+0x798>
    80000cac:	0305e863          	bltu	a1,a6,80000cdc <cbvprintf+0x68c>
    80000cb0:	00300593          	li	a1,3
    80000cb4:	12b80a63          	beq	a6,a1,80000de8 <cbvprintf+0x798>
    80000cb8:	00400593          	li	a1,4
    80000cbc:	12b80663          	beq	a6,a1,80000de8 <cbvprintf+0x798>
				value->sint = va_arg(ap, int);
    80000cc0:	0007a783          	lw	a5,0(a5)
				value->sint =
    80000cc4:	04f13023          	sd	a5,64(sp)
			if (length_mod == LENGTH_HH) {
    80000cc8:	03669463          	bne	a3,s6,80000cf0 <cbvprintf+0x6a0>
				value->uint = (unsigned char)value->uint;
    80000ccc:	04014783          	lbu	a5,64(sp)
    80000cd0:	02c0006f          	j	80000cfc <cbvprintf+0x6ac>
    80000cd4:	00058793          	mv	a5,a1
    80000cd8:	a55ff06f          	j	8000072c <cbvprintf+0xdc>
			switch (length_mod) {
    80000cdc:	00a8059b          	addiw	a1,a6,10
    80000ce0:	00f5f593          	andi	a1,a1,15
    80000ce4:	fcbb6ee3          	bltu	s6,a1,80000cc0 <cbvprintf+0x670>
				value->sint =
    80000ce8:	0007b783          	ld	a5,0(a5)
    80000cec:	fd9ff06f          	j	80000cc4 <cbvprintf+0x674>
			} else if (length_mod == LENGTH_H) {
    80000cf0:	00200793          	li	a5,2
    80000cf4:	0af69463          	bne	a3,a5,80000d9c <cbvprintf+0x74c>
				value->sint = (short)value->sint;
    80000cf8:	04011783          	lh	a5,64(sp)
			value->ptr = va_arg(ap, void *);
    80000cfc:	04f13023          	sd	a5,64(sp)
    80000d00:	09c0006f          	j	80000d9c <cbvprintf+0x74c>
		} else if (specifier_cat == SPECIFIER_UINT) {
    80000d04:	00200893          	li	a7,2
    80000d08:	07159463          	bne	a1,a7,80000d70 <cbvprintf+0x720>
			switch (length_mod) {
    80000d0c:	00500593          	li	a1,5
				value->sint = va_arg(ap, int);
    80000d10:	00878a13          	addi	s4,a5,8
			switch (length_mod) {
    80000d14:	0cb80a63          	beq	a6,a1,80000de8 <cbvprintf+0x798>
    80000d18:	0305e863          	bltu	a1,a6,80000d48 <cbvprintf+0x6f8>
    80000d1c:	00300593          	li	a1,3
    80000d20:	02b80e63          	beq	a6,a1,80000d5c <cbvprintf+0x70c>
    80000d24:	00400593          	li	a1,4
    80000d28:	0cb80063          	beq	a6,a1,80000de8 <cbvprintf+0x798>
				value->uint = va_arg(ap, unsigned int);
    80000d2c:	0007e783          	lwu	a5,0(a5)
				value->uint =
    80000d30:	04f13023          	sd	a5,64(sp)
			if (length_mod == LENGTH_HH) {
    80000d34:	f9668ce3          	beq	a3,s6,80000ccc <cbvprintf+0x67c>
			} else if (length_mod == LENGTH_H) {
    80000d38:	00200793          	li	a5,2
    80000d3c:	06f69063          	bne	a3,a5,80000d9c <cbvprintf+0x74c>
				value->uint = (unsigned short)value->uint;
    80000d40:	04015783          	lhu	a5,64(sp)
    80000d44:	fb9ff06f          	j	80000cfc <cbvprintf+0x6ac>
			switch (length_mod) {
    80000d48:	00a8059b          	addiw	a1,a6,10
    80000d4c:	00f5f593          	andi	a1,a1,15
    80000d50:	fcbb6ee3          	bltu	s6,a1,80000d2c <cbvprintf+0x6dc>
				value->uint =
    80000d54:	0007b783          	ld	a5,0(a5)
    80000d58:	fd9ff06f          	j	80000d30 <cbvprintf+0x6e0>
				if ((!WCHAR_IS_SIGNED)
    80000d5c:	05314583          	lbu	a1,83(sp)
    80000d60:	06300693          	li	a3,99
    80000d64:	08d59263          	bne	a1,a3,80000de8 <cbvprintf+0x798>
					value->uint = (wchar_t)va_arg(ap,
    80000d68:	0007a783          	lw	a5,0(a5)
    80000d6c:	f91ff06f          	j	80000cfc <cbvprintf+0x6ac>
		} else if (specifier_cat == SPECIFIER_FP) {
    80000d70:	00400893          	li	a7,4
    80000d74:	07159263          	bne	a1,a7,80000dd8 <cbvprintf+0x788>
			if (length_mod == LENGTH_UPPER_L) {
    80000d78:	00800593          	li	a1,8
    80000d7c:	04b81663          	bne	a6,a1,80000dc8 <cbvprintf+0x778>
				value->ldbl = va_arg(ap, long double);
    80000d80:	00f78693          	addi	a3,a5,15
    80000d84:	ff06f693          	andi	a3,a3,-16
    80000d88:	0006b783          	ld	a5,0(a3)
    80000d8c:	01068a13          	addi	s4,a3,16
    80000d90:	04f13023          	sd	a5,64(sp)
    80000d94:	0086b783          	ld	a5,8(a3)
    80000d98:	04f13423          	sd	a5,72(sp)
		if (conv->invalid || conv->unsupported) {
    80000d9c:	05012783          	lw	a5,80(sp)
    80000da0:	0037f793          	andi	a5,a5,3
    80000da4:	04078663          	beqz	a5,80000df0 <cbvprintf+0x7a0>
			OUTS(sp, fp);
    80000da8:	000a8693          	mv	a3,s5
    80000dac:	00090593          	mv	a1,s2
    80000db0:	00048513          	mv	a0,s1
    80000db4:	81dff0ef          	jal	ra,800005d0 <outs>
    80000db8:	7c054863          	bltz	a0,80001588 <cbvprintf+0xf38>
    80000dbc:	00a40433          	add	s0,s0,a0
			while (pad_len-- > 0) {
    80000dc0:	000a8613          	mv	a2,s5
    80000dc4:	8e5ff06f          	j	800006a8 <cbvprintf+0x58>
				value->dbl = va_arg(ap, double);
    80000dc8:	0007b787          	fld	fa5,0(a5)
    80000dcc:	00878a13          	addi	s4,a5,8
    80000dd0:	04f13027          	fsd	fa5,64(sp)
    80000dd4:	fc9ff06f          	j	80000d9c <cbvprintf+0x74c>
		} else if (specifier_cat == SPECIFIER_PTR) {
    80000dd8:	00300693          	li	a3,3
    80000ddc:	00078a13          	mv	s4,a5
    80000de0:	fad59ee3          	bne	a1,a3,80000d9c <cbvprintf+0x74c>
			value->ptr = va_arg(ap, void *);
    80000de4:	00878a13          	addi	s4,a5,8
    80000de8:	0007b783          	ld	a5,0(a5)
    80000dec:	f11ff06f          	j	80000cfc <cbvprintf+0x6ac>
		switch (conv->specifier) {
    80000df0:	05314d83          	lbu	s11,83(sp)
    80000df4:	07800793          	li	a5,120
    80000df8:	fdb7e4e3          	bltu	a5,s11,80000dc0 <cbvprintf+0x770>
    80000dfc:	05700793          	li	a5,87
    80000e00:	0bb7ec63          	bltu	a5,s11,80000eb8 <cbvprintf+0x868>
    80000e04:	02500793          	li	a5,37
    80000e08:	0cfd8e63          	beq	s11,a5,80000ee4 <cbvprintf+0x894>
    80000e0c:	02400793          	li	a5,36
    80000e10:	fbb7f8e3          	bgeu	a5,s11,80000dc0 <cbvprintf+0x770>
    80000e14:	04100793          	li	a5,65
    80000e18:	00fd8a63          	beq	s11,a5,80000e2c <cbvprintf+0x7dc>
    80000e1c:	fbbd879b          	addiw	a5,s11,-69
    80000e20:	0ff7f793          	andi	a5,a5,255
    80000e24:	00200693          	li	a3,2
    80000e28:	f8f6ece3          	bltu	a3,a5,80000dc0 <cbvprintf+0x770>
	} u = {
    80000e2c:	04013783          	ld	a5,64(sp)
		*sign = '-';
    80000e30:	02d00d13          	li	s10,45
	if ((u.u64 & SIGN_MASK) != 0U) {
    80000e34:	0007ce63          	bltz	a5,80000e50 <cbvprintf+0x800>
	} else if (conv->flag_plus) {
    80000e38:	05015683          	lhu	a3,80(sp)
		*sign = '+';
    80000e3c:	02b00d13          	li	s10,43
	} else if (conv->flag_plus) {
    80000e40:	0086f593          	andi	a1,a3,8
    80000e44:	00059663          	bnez	a1,80000e50 <cbvprintf+0x800>
		*sign = ' ';
    80000e48:	00169d13          	slli	s10,a3,0x1
    80000e4c:	020d7d13          	andi	s10,s10,32
	uint64_t fract = u.u64 & BIT64_MASK(FRACTION_BITS);
    80000e50:	fff00713          	li	a4,-1
    80000e54:	00c75713          	srli	a4,a4,0xc
	int expo = (u.u64 >> FRACTION_BITS) & BIT_MASK(EXPONENT_BITS);
    80000e58:	0347d693          	srli	a3,a5,0x34
	uint64_t fract = u.u64 & BIT64_MASK(FRACTION_BITS);
    80000e5c:	00e7f7b3          	and	a5,a5,a4
	int expo = (u.u64 >> FRACTION_BITS) & BIT_MASK(EXPONENT_BITS);
    80000e60:	7ff6f693          	andi	a3,a3,2047
	uint64_t fract = u.u64 & BIT64_MASK(FRACTION_BITS);
    80000e64:	00f13c23          	sd	a5,24(sp)
	bool is_subnormal = (expo == 0) && (fract != 0);
    80000e68:	00f035b3          	snez	a1,a5
    80000e6c:	28068863          	beqz	a3,800010fc <cbvprintf+0xaac>
	if (expo == BIT_MASK(EXPONENT_BITS)) {
    80000e70:	7ff00893          	li	a7,2047
	bool is_subnormal = (expo == 0) && (fract != 0);
    80000e74:	00000593          	li	a1,0
	if (expo == BIT_MASK(EXPONENT_BITS)) {
    80000e78:	29169263          	bne	a3,a7,800010fc <cbvprintf+0xaac>
    80000e7c:	fbfd861b          	addiw	a2,s11,-65
		if (fract == 0) {
    80000e80:	24079863          	bnez	a5,800010d0 <cbvprintf+0xa80>
			if (isupper((int)c)) {
    80000e84:	01900793          	li	a5,25
    80000e88:	22c7e863          	bltu	a5,a2,800010b8 <cbvprintf+0xa68>
				*buf++ = 'I';
    80000e8c:	04900793          	li	a5,73
    80000e90:	02f10023          	sb	a5,32(sp)
				*buf++ = 'N';
    80000e94:	04e00793          	li	a5,78
    80000e98:	02f100a3          	sb	a5,33(sp)
				*buf++ = 'F';
    80000e9c:	04600793          	li	a5,70
				*buf++ = 'n';
    80000ea0:	02f10123          	sb	a5,34(sp)
		conv->flag_zero = false;
    80000ea4:	05015783          	lhu	a5,80(sp)
		*bpe = buf;
    80000ea8:	02310c93          	addi	s9,sp,35
		conv->flag_zero = false;
    80000eac:	fbf7f793          	andi	a5,a5,-65
    80000eb0:	04f11823          	sh	a5,80(sp)
		return bps;
    80000eb4:	0880006f          	j	80000f3c <cbvprintf+0x8ec>
		switch (conv->specifier) {
    80000eb8:	fa8d869b          	addiw	a3,s11,-88
    80000ebc:	0ff6f693          	andi	a3,a3,255
    80000ec0:	02000793          	li	a5,32
    80000ec4:	eed7eee3          	bltu	a5,a3,80000dc0 <cbvprintf+0x770>
    80000ec8:	00002597          	auipc	a1,0x2
    80000ecc:	2dc58593          	addi	a1,a1,732 # 800031a4 <levels.0+0xac>
    80000ed0:	00269693          	slli	a3,a3,0x2
    80000ed4:	00b686b3          	add	a3,a3,a1
    80000ed8:	0006a783          	lw	a5,0(a3)
    80000edc:	00b787b3          	add	a5,a5,a1
    80000ee0:	00078067          	jr	a5
			OUTC('%');
    80000ee4:	00090593          	mv	a1,s2
    80000ee8:	02500513          	li	a0,37
    80000eec:	000480e7          	jalr	s1
    80000ef0:	68054c63          	bltz	a0,80001588 <cbvprintf+0xf38>
    80000ef4:	00140413          	addi	s0,s0,1
		if (bps == NULL) {
    80000ef8:	ec9ff06f          	j	80000dc0 <cbvprintf+0x770>
			bps = (const char *)value->ptr;
    80000efc:	04013d83          	ld	s11,64(sp)
			if (precision >= 0) {
    80000f00:	020bc063          	bltz	s7,80000f20 <cbvprintf+0x8d0>
				len = strnlen(bps, precision);
    80000f04:	000b8593          	mv	a1,s7
    80000f08:	000d8513          	mv	a0,s11
    80000f0c:	1b1000ef          	jal	ra,800018bc <strnlen>
			bpe = bps + len;
    80000f10:	00ad8cb3          	add	s9,s11,a0
		char sign = 0;
    80000f14:	00000d13          	li	s10,0
		if (bps == NULL) {
    80000f18:	020d9463          	bnez	s11,80000f40 <cbvprintf+0x8f0>
    80000f1c:	ea5ff06f          	j	80000dc0 <cbvprintf+0x770>
				len = strlen(bps);
    80000f20:	000d8513          	mv	a0,s11
    80000f24:	179000ef          	jal	ra,8000189c <strlen>
    80000f28:	fe9ff06f          	j	80000f10 <cbvprintf+0x8c0>
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
    80000f2c:	04013783          	ld	a5,64(sp)
		char sign = 0;
    80000f30:	00000d13          	li	s10,0
			bpe = buf + 1;
    80000f34:	02110c93          	addi	s9,sp,33
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
    80000f38:	02f10023          	sb	a5,32(sp)
				bps = encode_float(value->dbl, conv, precision,
    80000f3c:	02010d93          	addi	s11,sp,32
		size_t nj_len = (bpe - bps);
    80000f40:	41bc87b3          	sub	a5,s9,s11
		if (sign != 0) {
    80000f44:	000d0463          	beqz	s10,80000f4c <cbvprintf+0x8fc>
			nj_len += 1U;
    80000f48:	00178793          	addi	a5,a5,1
		if (conv->altform_0c) {
    80000f4c:	05214603          	lbu	a2,82(sp)
    80000f50:	01067713          	andi	a4,a2,16
    80000f54:	54070e63          	beqz	a4,800014b0 <cbvprintf+0xe60>
			nj_len += 2U;
    80000f58:	00278793          	addi	a5,a5,2
		nj_len += conv->pad0_value;
    80000f5c:	05412703          	lw	a4,84(sp)
		if (conv->pad_fp) {
    80000f60:	04067613          	andi	a2,a2,64
		nj_len += conv->pad0_value;
    80000f64:	00f707b3          	add	a5,a4,a5
		if (conv->pad_fp) {
    80000f68:	00060663          	beqz	a2,80000f74 <cbvprintf+0x924>
			nj_len += conv->pad0_pre_exp;
    80000f6c:	05812703          	lw	a4,88(sp)
    80000f70:	00e787b3          	add	a5,a5,a4
		if (width > 0) {
    80000f74:	57305a63          	blez	s3,800014e8 <cbvprintf+0xe98>
			width -= (int)nj_len;
    80000f78:	40f989bb          	subw	s3,s3,a5
			if (!conv->flag_dash) {
    80000f7c:	05013783          	ld	a5,80(sp)
    80000f80:	0027d793          	srli	a5,a5,0x2
    80000f84:	0017f793          	andi	a5,a5,1
    80000f88:	56079063          	bnez	a5,800014e8 <cbvprintf+0xe98>
				if (conv->flag_zero) {
    80000f8c:	05015783          	lhu	a5,80(sp)
    80000f90:	0407f793          	andi	a5,a5,64
    80000f94:	5c078a63          	beqz	a5,80001568 <cbvprintf+0xf18>
					if (sign != 0) {
    80000f98:	000d0e63          	beqz	s10,80000fb4 <cbvprintf+0x964>
						OUTC(sign);
    80000f9c:	00090593          	mv	a1,s2
    80000fa0:	000d0513          	mv	a0,s10
    80000fa4:	000480e7          	jalr	s1
    80000fa8:	5e054063          	bltz	a0,80001588 <cbvprintf+0xf38>
    80000fac:	00140413          	addi	s0,s0,1
						sign = 0;
    80000fb0:	00000d13          	li	s10,0
					pad = '0';
    80000fb4:	03000513          	li	a0,48
    80000fb8:	5b40006f          	j	8000156c <cbvprintf+0xf1c>
			if (conv->flag_plus) {
    80000fbc:	05015783          	lhu	a5,80(sp)
				sign = '+';
    80000fc0:	02b00d13          	li	s10,43
			if (conv->flag_plus) {
    80000fc4:	0087f693          	andi	a3,a5,8
    80000fc8:	00069663          	bnez	a3,80000fd4 <cbvprintf+0x984>
				sign = ' ';
    80000fcc:	00179d13          	slli	s10,a5,0x1
    80000fd0:	020d7d13          	andi	s10,s10,32
			sint = value->sint;
    80000fd4:	04013783          	ld	a5,64(sp)
			if (sint < 0) {
    80000fd8:	0007d863          	bgez	a5,80000fe8 <cbvprintf+0x998>
				value->uint = (uint_value_type)-sint;
    80000fdc:	40f007b3          	neg	a5,a5
    80000fe0:	04f13023          	sd	a5,64(sp)
				sign = '-';
    80000fe4:	02d00d13          	li	s10,45
			bps = encode_uint(value->uint, conv, buf, bpe);
    80000fe8:	04013503          	ld	a0,64(sp)
    80000fec:	03910693          	addi	a3,sp,57
    80000ff0:	02010613          	addi	a2,sp,32
    80000ff4:	05010593          	addi	a1,sp,80
    80000ff8:	d20ff0ef          	jal	ra,80000518 <encode_uint>
    80000ffc:	00050d93          	mv	s11,a0
			if (precision >= 0) {
    80001000:	03910c93          	addi	s9,sp,57
    80001004:	f00bcae3          	bltz	s7,80000f18 <cbvprintf+0x8c8>
				conv->flag_zero = false;
    80001008:	05015603          	lhu	a2,80(sp)
				size_t len = bpe - bps;
    8000100c:	41bc87b3          	sub	a5,s9,s11
				conv->flag_zero = false;
    80001010:	fbf67613          	andi	a2,a2,-65
    80001014:	04c11823          	sh	a2,80(sp)
				if (len < (size_t)precision) {
    80001018:	f177f0e3          	bgeu	a5,s7,80000f18 <cbvprintf+0x8c8>
					conv->pad0_value = precision - (int)len;
    8000101c:	40fb87bb          	subw	a5,s7,a5
    80001020:	04f12a23          	sw	a5,84(sp)
    80001024:	ef5ff06f          	j	80000f18 <cbvprintf+0x8c8>
		switch (conv->specifier) {
    80001028:	00000d13          	li	s10,0
    8000102c:	fbdff06f          	j	80000fe8 <cbvprintf+0x998>
			if (value->ptr != NULL) {
    80001030:	04013503          	ld	a0,64(sp)
    80001034:	46050263          	beqz	a0,80001498 <cbvprintf+0xe48>
				bps = encode_uint((uintptr_t)value->ptr, conv,
    80001038:	03910693          	addi	a3,sp,57
    8000103c:	02010613          	addi	a2,sp,32
    80001040:	05010593          	addi	a1,sp,80
    80001044:	cd4ff0ef          	jal	ra,80000518 <encode_uint>
				conv->altform_0c = true;
    80001048:	05215783          	lhu	a5,82(sp)
    8000104c:	000086b7          	lui	a3,0x8
    80001050:	81068693          	addi	a3,a3,-2032 # 7810 <__rom_region_size+0x45c8>
    80001054:	0ef7f793          	andi	a5,a5,239
    80001058:	00d7e7b3          	or	a5,a5,a3
				bps = encode_uint((uintptr_t)value->ptr, conv,
    8000105c:	00050d93          	mv	s11,a0
				conv->altform_0c = true;
    80001060:	04f11923          	sh	a5,82(sp)
		char sign = 0;
    80001064:	00000d13          	li	s10,0
				goto prec_int_pad0;
    80001068:	f99ff06f          	j	80001000 <cbvprintf+0x9b0>
	switch ((enum length_mod_enum)conv->length_mod) {
    8000106c:	00700793          	li	a5,7
				store_count(conv, value->ptr, count);
    80001070:	04013703          	ld	a4,64(sp)
    80001074:	0004069b          	sext.w	a3,s0
	switch ((enum length_mod_enum)conv->length_mod) {
    80001078:	d507e4e3          	bltu	a5,a6,80000dc0 <cbvprintf+0x770>
    8000107c:	00002617          	auipc	a2,0x2
    80001080:	1ac60613          	addi	a2,a2,428 # 80003228 <levels.0+0x130>
    80001084:	00281793          	slli	a5,a6,0x2
    80001088:	00c787b3          	add	a5,a5,a2
    8000108c:	0007a783          	lw	a5,0(a5)
    80001090:	00c787b3          	add	a5,a5,a2
    80001094:	00078067          	jr	a5
		*(int *)dp = count;
    80001098:	00d72023          	sw	a3,0(a4) # 4000 <__rom_region_size+0xdb8>
		break;
    8000109c:	d25ff06f          	j	80000dc0 <cbvprintf+0x770>
		*(signed char *)dp = (signed char)count;
    800010a0:	00870023          	sb	s0,0(a4)
		break;
    800010a4:	d1dff06f          	j	80000dc0 <cbvprintf+0x770>
		*(short *)dp = (short)count;
    800010a8:	00871023          	sh	s0,0(a4)
		break;
    800010ac:	d15ff06f          	j	80000dc0 <cbvprintf+0x770>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
    800010b0:	00d73023          	sd	a3,0(a4)
		break;
    800010b4:	d0dff06f          	j	80000dc0 <cbvprintf+0x770>
				*buf++ = 'i';
    800010b8:	06900793          	li	a5,105
    800010bc:	02f10023          	sb	a5,32(sp)
				*buf++ = 'n';
    800010c0:	06e00793          	li	a5,110
    800010c4:	02f100a3          	sb	a5,33(sp)
				*buf++ = 'f';
    800010c8:	06600793          	li	a5,102
    800010cc:	dd5ff06f          	j	80000ea0 <cbvprintf+0x850>
			if (isupper((int)c)) {
    800010d0:	01900793          	li	a5,25
    800010d4:	00c7ec63          	bltu	a5,a2,800010ec <cbvprintf+0xa9c>
				*buf++ = 'N';
    800010d8:	04e00793          	li	a5,78
    800010dc:	02f10023          	sb	a5,32(sp)
				*buf++ = 'A';
    800010e0:	04100713          	li	a4,65
				*buf++ = 'a';
    800010e4:	02e100a3          	sb	a4,33(sp)
    800010e8:	db9ff06f          	j	80000ea0 <cbvprintf+0x850>
				*buf++ = 'n';
    800010ec:	06e00793          	li	a5,110
    800010f0:	02f10023          	sb	a5,32(sp)
				*buf++ = 'a';
    800010f4:	06100713          	li	a4,97
    800010f8:	fedff06f          	j	800010e4 <cbvprintf+0xa94>
	if (c == 'F') {
    800010fc:	04600893          	li	a7,70
    80001100:	011d9463          	bne	s11,a7,80001108 <cbvprintf+0xab8>
		c = 'f';
    80001104:	06600d93          	li	s11,102
	fract <<= EXPONENT_BITS;
    80001108:	00b79793          	slli	a5,a5,0xb
	fract &= ~SIGN_MASK;
    8000110c:	00f13c23          	sd	a5,24(sp)
	if ((expo | fract) != 0) {
    80001110:	00f6e8b3          	or	a7,a3,a5
    80001114:	1e088463          	beqz	a7,800012fc <cbvprintf+0xcac>
		if (is_subnormal) {
    80001118:	18059263          	bnez	a1,8000129c <cbvprintf+0xc4c>
		fract |= BIT_63;
    8000111c:	01813583          	ld	a1,24(sp)
    80001120:	fff00793          	li	a5,-1
    80001124:	03f79793          	slli	a5,a5,0x3f
    80001128:	00f5e5b3          	or	a1,a1,a5
		expo -= (1023 - 1);	/* +1 since .1 vs 1. */
    8000112c:	c026869b          	addiw	a3,a3,-1022
		fract |= BIT_63;
    80001130:	00b13c23          	sd	a1,24(sp)
    80001134:	00000893          	li	a7,0
    80001138:	00000c13          	li	s8,0
	while (expo < -2) {
    8000113c:	ffe00313          	li	t1,-2
		fract *= 5U;
    80001140:	00500e13          	li	t3,5
	while (expo < -2) {
    80001144:	1666c463          	blt	a3,t1,800012ac <cbvprintf+0xc5c>
    80001148:	00088463          	beqz	a7,80001150 <cbvprintf+0xb00>
    8000114c:	00b13c23          	sd	a1,24(sp)
    80001150:	01813583          	ld	a1,24(sp)
		decexp--;
    80001154:	00000893          	li	a7,0
	*v /= 5U;
    80001158:	00500313          	li	t1,5
	while (expo > 0) {
    8000115c:	16d04e63          	bgtz	a3,800012d8 <cbvprintf+0xc88>
    80001160:	00088463          	beqz	a7,80001168 <cbvprintf+0xb18>
    80001164:	00b13c23          	sd	a1,24(sp)
	fract >>= (4 - expo);
    80001168:	00400593          	li	a1,4
    8000116c:	40d586bb          	subw	a3,a1,a3
    80001170:	01813583          	ld	a1,24(sp)
	if ((c == 'g') || (c == 'G')) {
    80001174:	04700893          	li	a7,71
	bool prune_zero = false;
    80001178:	00013023          	sd	zero,0(sp)
	fract >>= (4 - expo);
    8000117c:	00d5d6b3          	srl	a3,a1,a3
	if ((c == 'g') || (c == 'G')) {
    80001180:	0dfdf593          	andi	a1,s11,223
    80001184:	03159c63          	bne	a1,a7,800011bc <cbvprintf+0xb6c>
		if (decexp < (-4 + 1) || decexp > precision) {
    80001188:	ffd00593          	li	a1,-3
    8000118c:	00bc4463          	blt	s8,a1,80001194 <cbvprintf+0xb44>
    80001190:	178bdc63          	bge	s7,s8,80001308 <cbvprintf+0xcb8>
			c += 'e' - 'g';  /* e or E */
    80001194:	ffed861b          	addiw	a2,s11,-2
    80001198:	0ff67d93          	andi	s11,a2,255
			if (precision > 0) {
    8000119c:	01705463          	blez	s7,800011a4 <cbvprintf+0xb54>
				precision--;
    800011a0:	fffb8b9b          	addiw	s7,s7,-1
		if (!conv->flag_hash && (precision > 0)) {
    800011a4:	00555513          	srli	a0,a0,0x5
    800011a8:	00157513          	andi	a0,a0,1
	bool prune_zero = false;
    800011ac:	00013023          	sd	zero,0(sp)
		if (!conv->flag_hash && (precision > 0)) {
    800011b0:	00051663          	bnez	a0,800011bc <cbvprintf+0xb6c>
    800011b4:	017027b3          	sgtz	a5,s7
    800011b8:	00f13023          	sd	a5,0(sp)
	if (c == 'f') {
    800011bc:	06600593          	li	a1,102
    800011c0:	14bd9a63          	bne	s11,a1,80001314 <cbvprintf+0xcc4>
		decimals = precision + decexp;
    800011c4:	017c053b          	addw	a0,s8,s7
		if (decimals < 0) {
    800011c8:	14055863          	bgez	a0,80001318 <cbvprintf+0xcc8>
			decimals = 0;
    800011cc:	00000593          	li	a1,0
    800011d0:	01000513          	li	a0,16
    800011d4:	00100793          	li	a5,1
    800011d8:	00a12a23          	sw	a0,20(sp)
	*v /= 5U;
    800011dc:	00500893          	li	a7,5
			decimals = 0;
    800011e0:	03b79513          	slli	a0,a5,0x3b
	while (decimals--) {
    800011e4:	fff5859b          	addiw	a1,a1,-1
    800011e8:	fff00793          	li	a5,-1
    800011ec:	14f59063          	bne	a1,a5,8000132c <cbvprintf+0xcdc>
	fract += round;
    800011f0:	00a686b3          	add	a3,a3,a0
	if (fract >= BIT64(60)) {
    800011f4:	0047d593          	srli	a1,a5,0x4
    800011f8:	14d5e063          	bltu	a1,a3,80001338 <cbvprintf+0xce8>
	fract += round;
    800011fc:	00d13c23          	sd	a3,24(sp)
	if (c == 'f') {
    80001200:	06600693          	li	a3,102
    80001204:	16dd9263          	bne	s11,a3,80001368 <cbvprintf+0xd18>
		if (decexp > 0) {
    80001208:	15805463          	blez	s8,80001350 <cbvprintf+0xd00>
	char *buf = bps;
    8000120c:	02010c93          	addi	s9,sp,32
				*buf++ = _get_digit(&fract, &digit_count);
    80001210:	01410593          	addi	a1,sp,20
    80001214:	01810513          	addi	a0,sp,24
    80001218:	001c8c93          	addi	s9,s9,1
    8000121c:	ab8ff0ef          	jal	ra,800004d4 <_get_digit>
    80001220:	feac8fa3          	sb	a0,-1(s9)
				decexp--;
    80001224:	fffc0c1b          	addiw	s8,s8,-1
			while (decexp > 0 && digit_count > 0) {
    80001228:	000c0663          	beqz	s8,80001234 <cbvprintf+0xbe4>
    8000122c:	01412583          	lw	a1,20(sp)
    80001230:	feb040e3          	bgtz	a1,80001210 <cbvprintf+0xbc0>
			conv->pad0_value = decexp;
    80001234:	05812a23          	sw	s8,84(sp)
			decexp = 0;
    80001238:	00000c13          	li	s8,0
		if (conv->flag_hash || (precision > 0)) {
    8000123c:	05015583          	lhu	a1,80(sp)
    80001240:	0205f593          	andi	a1,a1,32
    80001244:	00059463          	bnez	a1,8000124c <cbvprintf+0xbfc>
    80001248:	19705263          	blez	s7,800013cc <cbvprintf+0xd7c>
			*buf++ = '.';
    8000124c:	02e00593          	li	a1,46
    80001250:	00bc8023          	sb	a1,0(s9)
    80001254:	001c8513          	addi	a0,s9,1
		if (decexp < 0 && precision > 0) {
    80001258:	020c0c63          	beqz	s8,80001290 <cbvprintf+0xc40>
			*buf++ = '.';
    8000125c:	00050c93          	mv	s9,a0
		if (decexp < 0 && precision > 0) {
    80001260:	17705663          	blez	s7,800013cc <cbvprintf+0xd7c>
			conv->pad0_value = -decexp;
    80001264:	418005bb          	negw	a1,s8
			if (conv->pad0_value > precision) {
    80001268:	0ebbcc63          	blt	s7,a1,80001360 <cbvprintf+0xd10>
			conv->pad0_value = -decexp;
    8000126c:	04b12a23          	sw	a1,84(sp)
			precision -= conv->pad0_value;
    80001270:	05412683          	lw	a3,84(sp)
			conv->pad_postdp = (conv->pad0_value > 0);
    80001274:	05214583          	lbu	a1,82(sp)
			precision -= conv->pad0_value;
    80001278:	40db8bbb          	subw	s7,s7,a3
			conv->pad_postdp = (conv->pad0_value > 0);
    8000127c:	00d026b3          	sgtz	a3,a3
    80001280:	0056969b          	slliw	a3,a3,0x5
    80001284:	fdf5f593          	andi	a1,a1,-33
    80001288:	00d5e6b3          	or	a3,a1,a3
    8000128c:	04d10923          	sb	a3,82(sp)
			*buf++ = '.';
    80001290:	00050c93          	mv	s9,a0
    80001294:	12c0006f          	j	800013c0 <cbvprintf+0xd70>
				expo--;
    80001298:	fff6869b          	addiw	a3,a3,-1
			while (((fract <<= 1) & BIT_63) == 0) {
    8000129c:	00179793          	slli	a5,a5,0x1
    800012a0:	fe07dce3          	bgez	a5,80001298 <cbvprintf+0xc48>
    800012a4:	00f13c23          	sd	a5,24(sp)
    800012a8:	e75ff06f          	j	8000111c <cbvprintf+0xacc>
		} while ((uint32_t)(fract >> 32) >= (UINT32_MAX / 5U));
    800012ac:	00813783          	ld	a5,8(sp)
    800012b0:	0215d893          	srli	a7,a1,0x21
    800012b4:	00068e93          	mv	t4,a3
    800012b8:	0015d593          	srli	a1,a1,0x1
			expo++;
    800012bc:	0016869b          	addiw	a3,a3,1
		} while ((uint32_t)(fract >> 32) >= (UINT32_MAX / 5U));
    800012c0:	ff17e6e3          	bltu	a5,a7,800012ac <cbvprintf+0xc5c>
		fract *= 5U;
    800012c4:	03c585b3          	mul	a1,a1,t3
		expo++;
    800012c8:	002e869b          	addiw	a3,t4,2
		decexp--;
    800012cc:	fffc0c1b          	addiw	s8,s8,-1
    800012d0:	00100893          	li	a7,1
    800012d4:	e71ff06f          	j	80001144 <cbvprintf+0xaf4>
		fract += 2;
    800012d8:	00258593          	addi	a1,a1,2
	*v /= 5U;
    800012dc:	0265d5b3          	divu	a1,a1,t1
		expo--;
    800012e0:	fff6869b          	addiw	a3,a3,-1
		decexp++;
    800012e4:	001c0c1b          	addiw	s8,s8,1
    800012e8:	00100893          	li	a7,1
			fract <<= 1;
    800012ec:	00159593          	slli	a1,a1,0x1
			expo--;
    800012f0:	fff6869b          	addiw	a3,a3,-1
		} while (!(fract & BIT_63));
    800012f4:	fe05dce3          	bgez	a1,800012ec <cbvprintf+0xc9c>
    800012f8:	e65ff06f          	j	8000115c <cbvprintf+0xb0c>
    800012fc:	00000c13          	li	s8,0
    80001300:	00000693          	li	a3,0
    80001304:	e65ff06f          	j	80001168 <cbvprintf+0xb18>
			precision -= decexp;
    80001308:	418b8bbb          	subw	s7,s7,s8
			c = 'f';
    8000130c:	06600d93          	li	s11,102
    80001310:	e95ff06f          	j	800011a4 <cbvprintf+0xb54>
		decimals = precision + 1;
    80001314:	001b851b          	addiw	a0,s7,1
	if (decimals > 16) {
    80001318:	01000893          	li	a7,16
    8000131c:	0005059b          	sext.w	a1,a0
    80001320:	eaa8d8e3          	bge	a7,a0,800011d0 <cbvprintf+0xb80>
    80001324:	01000593          	li	a1,16
    80001328:	ea9ff06f          	j	800011d0 <cbvprintf+0xb80>
	*v >>= 1;
    8000132c:	00155513          	srli	a0,a0,0x1
	*v /= 5U;
    80001330:	03155533          	divu	a0,a0,a7
}
    80001334:	eb1ff06f          	j	800011e4 <cbvprintf+0xb94>
	*v >>= 1;
    80001338:	0016d693          	srli	a3,a3,0x1
	*v /= 5U;
    8000133c:	00500593          	li	a1,5
    80001340:	02b6d6b3          	divu	a3,a3,a1
		decexp++;
    80001344:	001c0c1b          	addiw	s8,s8,1
	*v /= 5U;
    80001348:	00d13c23          	sd	a3,24(sp)
		decexp++;
    8000134c:	eb5ff06f          	j	80001200 <cbvprintf+0xbb0>
			*buf++ = '0';
    80001350:	03000693          	li	a3,48
    80001354:	02d10023          	sb	a3,32(sp)
    80001358:	02110c93          	addi	s9,sp,33
    8000135c:	ee1ff06f          	j	8000123c <cbvprintf+0xbec>
				conv->pad0_value = precision;
    80001360:	05712a23          	sw	s7,84(sp)
    80001364:	f0dff06f          	j	80001270 <cbvprintf+0xc20>
		*buf = _get_digit(&fract, &digit_count);
    80001368:	01410593          	addi	a1,sp,20
    8000136c:	01810513          	addi	a0,sp,24
    80001370:	964ff0ef          	jal	ra,800004d4 <_get_digit>
    80001374:	02a10023          	sb	a0,32(sp)
		if (*buf++ != '0') {
    80001378:	03000693          	li	a3,48
    8000137c:	00d50463          	beq	a0,a3,80001384 <cbvprintf+0xd34>
			decexp--;
    80001380:	fffc0c1b          	addiw	s8,s8,-1
		if (conv->flag_hash || (precision > 0)) {
    80001384:	05015683          	lhu	a3,80(sp)
    80001388:	0206f693          	andi	a3,a3,32
    8000138c:	00069663          	bnez	a3,80001398 <cbvprintf+0xd48>
		if (*buf++ != '0') {
    80001390:	02110c93          	addi	s9,sp,33
		if (conv->flag_hash || (precision > 0)) {
    80001394:	03705c63          	blez	s7,800013cc <cbvprintf+0xd7c>
			*buf++ = '.';
    80001398:	02e00693          	li	a3,46
    8000139c:	02d100a3          	sb	a3,33(sp)
    800013a0:	02210513          	addi	a0,sp,34
    800013a4:	eedff06f          	j	80001290 <cbvprintf+0xc40>
		*buf++ = _get_digit(&fract, &digit_count);
    800013a8:	01410593          	addi	a1,sp,20
    800013ac:	01810513          	addi	a0,sp,24
    800013b0:	001c8c93          	addi	s9,s9,1
    800013b4:	920ff0ef          	jal	ra,800004d4 <_get_digit>
    800013b8:	feac8fa3          	sb	a0,-1(s9)
		precision--;
    800013bc:	fffb8b9b          	addiw	s7,s7,-1
	while (precision > 0 && digit_count > 0) {
    800013c0:	01705663          	blez	s7,800013cc <cbvprintf+0xd7c>
    800013c4:	01412583          	lw	a1,20(sp)
    800013c8:	feb040e3          	bgtz	a1,800013a8 <cbvprintf+0xd58>
	if (prune_zero) {
    800013cc:	00013783          	ld	a5,0(sp)
    800013d0:	0a079063          	bnez	a5,80001470 <cbvprintf+0xe20>
	conv->pad0_pre_exp = precision;
    800013d4:	05712c23          	sw	s7,88(sp)
	if ((c == 'e') || (c == 'E')) {
    800013d8:	0dfdf713          	andi	a4,s11,223
    800013dc:	04500593          	li	a1,69
    800013e0:	06b71063          	bne	a4,a1,80001440 <cbvprintf+0xdf0>
		*buf++ = c;
    800013e4:	01bc8023          	sb	s11,0(s9)
			*buf++ = '-';
    800013e8:	002c8713          	addi	a4,s9,2
			*buf++ = '+';
    800013ec:	02b00613          	li	a2,43
		if (decexp < 0) {
    800013f0:	000c5663          	bgez	s8,800013fc <cbvprintf+0xdac>
			decexp = -decexp;
    800013f4:	41800c3b          	negw	s8,s8
			*buf++ = '-';
    800013f8:	02d00613          	li	a2,45
    800013fc:	00cc80a3          	sb	a2,1(s9)
		if (decexp >= 100) {
    80001400:	06300613          	li	a2,99
    80001404:	01865e63          	bge	a2,s8,80001420 <cbvprintf+0xdd0>
			*buf++ = (decexp / 100) + '0';
    80001408:	06400593          	li	a1,100
    8000140c:	02bc463b          	divw	a2,s8,a1
    80001410:	003c8713          	addi	a4,s9,3
			decexp %= 100;
    80001414:	02bc6c3b          	remw	s8,s8,a1
			*buf++ = (decexp / 100) + '0';
    80001418:	0306061b          	addiw	a2,a2,48
    8000141c:	00cc8123          	sb	a2,2(s9)
		*buf++ = (decexp / 10) + '0';
    80001420:	00a00613          	li	a2,10
		*buf++ = (decexp % 10) + '0';
    80001424:	00270c93          	addi	s9,a4,2
		*buf++ = (decexp / 10) + '0';
    80001428:	02cc46bb          	divw	a3,s8,a2
		*buf++ = (decexp % 10) + '0';
    8000142c:	02cc67bb          	remw	a5,s8,a2
		*buf++ = (decexp / 10) + '0';
    80001430:	0306869b          	addiw	a3,a3,48
    80001434:	00d70023          	sb	a3,0(a4)
		*buf++ = (decexp % 10) + '0';
    80001438:	0307879b          	addiw	a5,a5,48
    8000143c:	00f700a3          	sb	a5,1(a4)
		|| (conv->pad0_pre_exp > 0);
    80001440:	05412703          	lw	a4,84(sp)
    80001444:	00100793          	li	a5,1
    80001448:	00e04663          	bgtz	a4,80001454 <cbvprintf+0xe04>
    8000144c:	05812783          	lw	a5,88(sp)
    80001450:	00f027b3          	sgtz	a5,a5
	conv->pad_fp = (conv->pad0_value > 0)
    80001454:	05214703          	lbu	a4,82(sp)
    80001458:	0067979b          	slliw	a5,a5,0x6
    8000145c:	fbf77713          	andi	a4,a4,-65
    80001460:	00f767b3          	or	a5,a4,a5
    80001464:	04f10923          	sb	a5,82(sp)
	*buf = 0;
    80001468:	000c8023          	sb	zero,0(s9)
	return bps;
    8000146c:	ad1ff06f          	j	80000f3c <cbvprintf+0x8ec>
		conv->pad0_pre_exp = 0;
    80001470:	04012c23          	sw	zero,88(sp)
		while (*--buf == '0') {
    80001474:	03000513          	li	a0,48
    80001478:	000c8593          	mv	a1,s9
    8000147c:	fffcc703          	lbu	a4,-1(s9)
    80001480:	fffc8c93          	addi	s9,s9,-1
    80001484:	fea70ae3          	beq	a4,a0,80001478 <cbvprintf+0xe28>
		if (*buf != '.') {
    80001488:	02e00513          	li	a0,46
    8000148c:	f4a706e3          	beq	a4,a0,800013d8 <cbvprintf+0xd88>
    80001490:	00058c93          	mv	s9,a1
    80001494:	f45ff06f          	j	800013d8 <cbvprintf+0xd88>
		char sign = 0;
    80001498:	00000d13          	li	s10,0
			bpe = bps + 5;
    8000149c:	00002c97          	auipc	s9,0x2
    800014a0:	bd9c8c93          	addi	s9,s9,-1063 # 80003075 <_k_neg_eagain+0x15>
			bps = "(nil)";
    800014a4:	00002d97          	auipc	s11,0x2
    800014a8:	bccd8d93          	addi	s11,s11,-1076 # 80003070 <_k_neg_eagain+0x10>
    800014ac:	a95ff06f          	j	80000f40 <cbvprintf+0x8f0>
		} else if (conv->altform_0) {
    800014b0:	00867713          	andi	a4,a2,8
    800014b4:	aa0704e3          	beqz	a4,80000f5c <cbvprintf+0x90c>
			nj_len += 1U;
    800014b8:	00178793          	addi	a5,a5,1
    800014bc:	aa1ff06f          	j	80000f5c <cbvprintf+0x90c>
					OUTC(pad);
    800014c0:	00090593          	mv	a1,s2
    800014c4:	00078513          	mv	a0,a5
    800014c8:	00f13023          	sd	a5,0(sp)
    800014cc:	000480e7          	jalr	s1
    800014d0:	0a054c63          	bltz	a0,80001588 <cbvprintf+0xf38>
    800014d4:	00013783          	ld	a5,0(sp)
    800014d8:	00140413          	addi	s0,s0,1
				while (width-- > 0) {
    800014dc:	00098713          	mv	a4,s3
    800014e0:	fff9899b          	addiw	s3,s3,-1
    800014e4:	fce04ee3          	bgtz	a4,800014c0 <cbvprintf+0xe70>
		if (sign != 0) {
    800014e8:	000d0c63          	beqz	s10,80001500 <cbvprintf+0xeb0>
			OUTC(sign);
    800014ec:	00090593          	mv	a1,s2
    800014f0:	000d0513          	mv	a0,s10
    800014f4:	000480e7          	jalr	s1
    800014f8:	08054863          	bltz	a0,80001588 <cbvprintf+0xf38>
    800014fc:	00140413          	addi	s0,s0,1
		if (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT) && conv->pad_fp) {
    80001500:	05214783          	lbu	a5,82(sp)
    80001504:	0407f793          	andi	a5,a5,64
    80001508:	1a078e63          	beqz	a5,800016c4 <cbvprintf+0x1074>
			if (conv->specifier_a) {
    8000150c:	05011783          	lh	a5,80(sp)
    80001510:	41b40433          	sub	s0,s0,s11
    80001514:	000d8d13          	mv	s10,s11
				while (isdigit((int)*cp)) {
    80001518:	00900713          	li	a4,9
			if (conv->specifier_a) {
    8000151c:	0a07de63          	bgez	a5,800015d8 <cbvprintf+0xf88>
				while (*cp != 'p') {
    80001520:	07000d93          	li	s11,112
    80001524:	000d4503          	lbu	a0,0(s10)
    80001528:	008d07b3          	add	a5,s10,s0
    8000152c:	05b51663          	bne	a0,s11,80001578 <cbvprintf+0xf28>
			pad_len = conv->pad0_pre_exp;
    80001530:	05812403          	lw	s0,88(sp)
			while (pad_len-- > 0) {
    80001534:	00078d93          	mv	s11,a5
    80001538:	00f4043b          	addw	s0,s0,a5
    8000153c:	41b407bb          	subw	a5,s0,s11
    80001540:	16f04663          	bgtz	a5,800016ac <cbvprintf+0x105c>
			OUTS(cp, bpe);
    80001544:	000c8693          	mv	a3,s9
    80001548:	000d0613          	mv	a2,s10
    8000154c:	00090593          	mv	a1,s2
    80001550:	00048513          	mv	a0,s1
    80001554:	87cff0ef          	jal	ra,800005d0 <outs>
    80001558:	02054863          	bltz	a0,80001588 <cbvprintf+0xf38>
    8000155c:	01b50433          	add	s0,a0,s11
    80001560:	008989bb          	addw	s3,s3,s0
    80001564:	2140006f          	j	80001778 <cbvprintf+0x1128>
				char pad = ' ';
    80001568:	02000513          	li	a0,32
					pad = '0';
    8000156c:	00098713          	mv	a4,s3
					OUTC(pad);
    80001570:	0005079b          	sext.w	a5,a0
    80001574:	f6dff06f          	j	800014e0 <cbvprintf+0xe90>
					OUTC(*cp++);
    80001578:	00090593          	mv	a1,s2
    8000157c:	001d0d13          	addi	s10,s10,1
    80001580:	000480e7          	jalr	s1
    80001584:	fa0550e3          	bgez	a0,80001524 <cbvprintf+0xed4>
#undef OUTS
#undef OUTC
}
    80001588:	0c813083          	ld	ra,200(sp)
    8000158c:	0c013403          	ld	s0,192(sp)
    80001590:	0b813483          	ld	s1,184(sp)
    80001594:	0b013903          	ld	s2,176(sp)
    80001598:	0a813983          	ld	s3,168(sp)
    8000159c:	0a013a03          	ld	s4,160(sp)
    800015a0:	09813a83          	ld	s5,152(sp)
    800015a4:	09013b03          	ld	s6,144(sp)
    800015a8:	08813b83          	ld	s7,136(sp)
    800015ac:	08013c03          	ld	s8,128(sp)
    800015b0:	07813c83          	ld	s9,120(sp)
    800015b4:	07013d03          	ld	s10,112(sp)
    800015b8:	06813d83          	ld	s11,104(sp)
    800015bc:	0d010113          	addi	sp,sp,208
    800015c0:	00008067          	ret
					OUTC(*cp++);
    800015c4:	00090593          	mv	a1,s2
    800015c8:	000480e7          	jalr	s1
    800015cc:	001d0d13          	addi	s10,s10,1
    800015d0:	00900713          	li	a4,9
    800015d4:	fa054ae3          	bltz	a0,80001588 <cbvprintf+0xf38>
				while (isdigit((int)*cp)) {
    800015d8:	000d4783          	lbu	a5,0(s10)
    800015dc:	008d0db3          	add	s11,s10,s0
    800015e0:	0007851b          	sext.w	a0,a5
    800015e4:	fd07879b          	addiw	a5,a5,-48
    800015e8:	fcf77ee3          	bgeu	a4,a5,800015c4 <cbvprintf+0xf74>
				if (!conv->pad_postdp) {
    800015ec:	05013783          	ld	a5,80(sp)
				pad_len = conv->pad0_value;
    800015f0:	05412403          	lw	s0,84(sp)
				if (!conv->pad_postdp) {
    800015f4:	0157d793          	srli	a5,a5,0x15
    800015f8:	0017f793          	andi	a5,a5,1
    800015fc:	00079863          	bnez	a5,8000160c <cbvprintf+0xfbc>
					while (pad_len-- > 0) {
    80001600:	fff4079b          	addiw	a5,s0,-1
    80001604:	04804063          	bgtz	s0,80001644 <cbvprintf+0xff4>
    80001608:	00078413          	mv	s0,a5
				if (*cp == '.') {
    8000160c:	000d4703          	lbu	a4,0(s10)
    80001610:	02e00793          	li	a5,46
    80001614:	02f71263          	bne	a4,a5,80001638 <cbvprintf+0xfe8>
					OUTC(*cp++);
    80001618:	00090593          	mv	a1,s2
    8000161c:	02e00513          	li	a0,46
    80001620:	000480e7          	jalr	s1
    80001624:	f60542e3          	bltz	a0,80001588 <cbvprintf+0xf38>
    80001628:	001d8d93          	addi	s11,s11,1
					while (pad_len-- > 0) {
    8000162c:	0004041b          	sext.w	s0,s0
    80001630:	02804c63          	bgtz	s0,80001668 <cbvprintf+0x1018>
					OUTC(*cp++);
    80001634:	001d0d13          	addi	s10,s10,1
    80001638:	41ad8433          	sub	s0,s11,s10
				while (isdigit((int)*cp)) {
    8000163c:	00900d93          	li	s11,9
    80001640:	0540006f          	j	80001694 <cbvprintf+0x1044>
						OUTC('0');
    80001644:	00090593          	mv	a1,s2
    80001648:	03000513          	li	a0,48
    8000164c:	00f13023          	sd	a5,0(sp)
    80001650:	000480e7          	jalr	s1
    80001654:	f2054ae3          	bltz	a0,80001588 <cbvprintf+0xf38>
					while (pad_len-- > 0) {
    80001658:	00013783          	ld	a5,0(sp)
						OUTC('0');
    8000165c:	001d8d93          	addi	s11,s11,1
					while (pad_len-- > 0) {
    80001660:	00078413          	mv	s0,a5
    80001664:	f9dff06f          	j	80001600 <cbvprintf+0xfb0>
						OUTC('0');
    80001668:	00090593          	mv	a1,s2
    8000166c:	03000513          	li	a0,48
    80001670:	000480e7          	jalr	s1
    80001674:	fff4041b          	addiw	s0,s0,-1
    80001678:	f00548e3          	bltz	a0,80001588 <cbvprintf+0xf38>
    8000167c:	001d8d93          	addi	s11,s11,1
    80001680:	fb1ff06f          	j	80001630 <cbvprintf+0xfe0>
					OUTC(*cp++);
    80001684:	00090593          	mv	a1,s2
    80001688:	001d0d13          	addi	s10,s10,1
    8000168c:	000480e7          	jalr	s1
    80001690:	ee054ce3          	bltz	a0,80001588 <cbvprintf+0xf38>
				while (isdigit((int)*cp)) {
    80001694:	000d4703          	lbu	a4,0(s10)
    80001698:	008d07b3          	add	a5,s10,s0
    8000169c:	0007051b          	sext.w	a0,a4
    800016a0:	fd07071b          	addiw	a4,a4,-48
    800016a4:	feedf0e3          	bgeu	s11,a4,80001684 <cbvprintf+0x1034>
    800016a8:	e89ff06f          	j	80001530 <cbvprintf+0xee0>
				OUTC('0');
    800016ac:	00090593          	mv	a1,s2
    800016b0:	03000513          	li	a0,48
    800016b4:	000480e7          	jalr	s1
    800016b8:	ec0548e3          	bltz	a0,80001588 <cbvprintf+0xf38>
    800016bc:	001d8d93          	addi	s11,s11,1
    800016c0:	e7dff06f          	j	8000153c <cbvprintf+0xeec>
			if (conv->altform_0c | conv->altform_0) {
    800016c4:	05013783          	ld	a5,80(sp)
    800016c8:	0147d713          	srli	a4,a5,0x14
    800016cc:	00177713          	andi	a4,a4,1
    800016d0:	00071863          	bnez	a4,800016e0 <cbvprintf+0x1090>
    800016d4:	0137d793          	srli	a5,a5,0x13
    800016d8:	0017f793          	andi	a5,a5,1
    800016dc:	00078c63          	beqz	a5,800016f4 <cbvprintf+0x10a4>
				OUTC('0');
    800016e0:	00090593          	mv	a1,s2
    800016e4:	03000513          	li	a0,48
    800016e8:	000480e7          	jalr	s1
    800016ec:	e8054ee3          	bltz	a0,80001588 <cbvprintf+0xf38>
    800016f0:	00140413          	addi	s0,s0,1
			if (conv->altform_0c) {
    800016f4:	05214783          	lbu	a5,82(sp)
    800016f8:	0107f793          	andi	a5,a5,16
    800016fc:	00078c63          	beqz	a5,80001714 <cbvprintf+0x10c4>
				OUTC(conv->specifier);
    80001700:	05314503          	lbu	a0,83(sp)
    80001704:	00090593          	mv	a1,s2
    80001708:	000480e7          	jalr	s1
    8000170c:	e6054ee3          	bltz	a0,80001588 <cbvprintf+0xf38>
    80001710:	00140413          	addi	s0,s0,1
			pad_len = conv->pad0_value;
    80001714:	05412783          	lw	a5,84(sp)
			while (pad_len-- > 0) {
    80001718:	008787bb          	addw	a5,a5,s0
    8000171c:	4087873b          	subw	a4,a5,s0
    80001720:	02e04263          	bgtz	a4,80001744 <cbvprintf+0x10f4>
			OUTS(bps, bpe);
    80001724:	000c8693          	mv	a3,s9
    80001728:	000d8613          	mv	a2,s11
    8000172c:	00090593          	mv	a1,s2
    80001730:	00048513          	mv	a0,s1
    80001734:	e9dfe0ef          	jal	ra,800005d0 <outs>
    80001738:	e40548e3          	bltz	a0,80001588 <cbvprintf+0xf38>
    8000173c:	00850433          	add	s0,a0,s0
    80001740:	e21ff06f          	j	80001560 <cbvprintf+0xf10>
				OUTC('0');
    80001744:	00090593          	mv	a1,s2
    80001748:	03000513          	li	a0,48
    8000174c:	00f12023          	sw	a5,0(sp)
    80001750:	000480e7          	jalr	s1
    80001754:	e2054ae3          	bltz	a0,80001588 <cbvprintf+0xf38>
    80001758:	00012783          	lw	a5,0(sp)
    8000175c:	00140413          	addi	s0,s0,1
    80001760:	fbdff06f          	j	8000171c <cbvprintf+0x10cc>
			OUTC(' ');
    80001764:	00090593          	mv	a1,s2
    80001768:	02000513          	li	a0,32
    8000176c:	000480e7          	jalr	s1
    80001770:	e0054ce3          	bltz	a0,80001588 <cbvprintf+0xf38>
    80001774:	00140413          	addi	s0,s0,1
		while (width > 0) {
    80001778:	408987bb          	subw	a5,s3,s0
    8000177c:	fef044e3          	bgtz	a5,80001764 <cbvprintf+0x1114>
    80001780:	e40ff06f          	j	80000dc0 <cbvprintf+0x770>

0000000080001784 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
    80001784:	00008067          	ret

0000000080001788 <arch_cpu_idle>:
 * '_pm_save_flag' variable is non-zero.
 *
 * @return N/A
 */
void arch_cpu_idle(void)
{
    80001788:	ff010113          	addi	sp,sp,-16
    8000178c:	00113423          	sd	ra,8(sp)
	sys_trace_idle();
    80001790:	040000ef          	jal	ra,800017d0 <sys_trace_idle>
 */
static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
	ulong_t mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
    80001794:	00800793          	li	a5,8
    80001798:	3007a7f3          	csrrs	a5,mstatus,a5
	__asm__ volatile("wfi");
    8000179c:	10500073          	wfi
	riscv_idle(MSTATUS_IEN);
}
    800017a0:	00813083          	ld	ra,8(sp)
    800017a4:	01010113          	addi	sp,sp,16
    800017a8:	00008067          	ret

00000000800017ac <arch_irq_enable>:
	 * CSR mie register is updated using atomic instruction csrrs
	 * (atomic read and set bits in CSR register)
	 */
	__asm__ volatile ("csrrs %0, mie, %1\n"
			  : "=r" (mie)
			  : "r" (1 << irq));
    800017ac:	00100793          	li	a5,1
    800017b0:	00a797bb          	sllw	a5,a5,a0
	__asm__ volatile ("csrrs %0, mie, %1\n"
    800017b4:	3047a7f3          	csrrs	a5,mie,a5
}
    800017b8:	00008067          	ret

00000000800017bc <soc_interrupt_init>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
    800017bc:	00800793          	li	a5,8
    800017c0:	3007b7f3          	csrrc	a5,mstatus,a5
__weak void soc_interrupt_init(void)
{
	/* ensure that all interrupts are disabled */
	(void)irq_lock();

	__asm__ volatile ("csrwi mie, 0\n"
    800017c4:	30405073          	csrwi	mie,0
    800017c8:	34405073          	csrwi	mip,0
			  "csrwi mip, 0\n");
}
    800017cc:	00008067          	ret

00000000800017d0 <sys_trace_idle>:
    800017d0:	00008067          	ret

00000000800017d4 <z_riscv_fatal_error>:
 #define NO_REG "                "
#endif

FUNC_NORETURN void z_riscv_fatal_error(unsigned int reason,
				       const z_arch_esf_t *esf)
{
    800017d4:	ff010113          	addi	sp,sp,-16
    800017d8:	00113423          	sd	ra,8(sp)
		LOG_ERR("   mepc: " PR_REG, esf->mepc);
		LOG_ERR("mstatus: " PR_REG, esf->mstatus);
		LOG_ERR("");
	}

	z_fatal_error(reason, esf);
    800017dc:	3e8000ef          	jal	ra,80001bc4 <z_fatal_error>

00000000800017e0 <_Fault>:
		return "unknown";
	}
}

void _Fault(z_arch_esf_t *esf)
{
    800017e0:	ff010113          	addi	sp,sp,-16
    800017e4:	00113423          	sd	ra,8(sp)
    800017e8:	00050593          	mv	a1,a0
		}
	}
#endif /* CONFIG_USERSPACE */
	ulong_t mcause;

	__asm__ volatile("csrr %0, mcause" : "=r" (mcause));
    800017ec:	342027f3          	csrr	a5,mcause

#ifndef CONFIG_SOC_OPENISA_RV32M1_RISCV32
	ulong_t mtval;
	__asm__ volatile("csrr %0, mtval" : "=r" (mtval));
    800017f0:	343027f3          	csrr	a5,mtval
	z_fatal_error(reason, esf);
    800017f4:	00000513          	li	a0,0
    800017f8:	3cc000ef          	jal	ra,80001bc4 <z_fatal_error>

00000000800017fc <z_irq_spurious>:
#include <kernel_internal.h>
#include <logging/log.h>
LOG_MODULE_DECLARE(os, CONFIG_KERNEL_LOG_LEVEL);

FUNC_NORETURN void z_irq_spurious(const void *unused)
{
    800017fc:	ff010113          	addi	sp,sp,-16
    80001800:	00113423          	sd	ra,8(sp)
	ulong_t mcause;

	ARG_UNUSED(unused);

	__asm__ volatile("csrr %0, mcause" : "=r" (mcause));
    80001804:	342027f3          	csrr	a5,mcause
	if (mcause == RISCV_MACHINE_EXT_IRQ) {
		LOG_ERR("PLIC interrupt line causing the IRQ: %d",
			riscv_plic_get_irq());
	}
#endif
	z_riscv_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
    80001808:	00000593          	li	a1,0
    8000180c:	00100513          	li	a0,1
    80001810:	fc5ff0ef          	jal	ra,800017d4 <z_riscv_fatal_error>

0000000080001814 <_PrepC>:
 *
 * @return N/A
 */

void _PrepC(void)
{
    80001814:	ff010113          	addi	sp,sp,-16
    80001818:	00113423          	sd	ra,8(sp)
	z_bss_zero();
    8000181c:	4e0000ef          	jal	ra,80001cfc <z_bss_zero>
#ifdef CONFIG_XIP
	z_data_copy();
#endif
#if defined(CONFIG_RISCV_SOC_INTERRUPT_INIT)
	soc_interrupt_init();
    80001820:	f9dff0ef          	jal	ra,800017bc <soc_interrupt_init>
#endif
#ifdef CONFIG_PMP_STACK_GUARD
	z_riscv_configure_interrupt_stack_guard();
#endif
	z_cstart();
    80001824:	4f4000ef          	jal	ra,80001d18 <z_cstart>

0000000080001828 <__initialize>:
SECTION_FUNC(TEXT, __initialize)
	/*
	 * This will boot master core, just halt other cores.
	 * Note: need to be updated for complete SMP support
	 */
	csrr a0, mhartid
    80001828:	f1402573          	csrr	a0,mhartid
	beqz a0, boot_master_core
    8000182c:	00050663          	beqz	a0,80001838 <boot_master_core>

0000000080001830 <loop_slave_core>:

loop_slave_core:
	wfi
    80001830:	10500073          	wfi
	j loop_slave_core
    80001834:	ffdff06f          	j	80001830 <loop_slave_core>

0000000080001838 <boot_master_core>:

#ifdef CONFIG_FPU
	/*
	 * Enable floating-point.
	 */
	li  t0, MSTATUS_FS_INIT
    80001838:	000022b7          	lui	t0,0x2
	csrrs x0, mstatus, t0
    8000183c:	3002a073          	csrs	mstatus,t0

	/*
	 * Floating-point rounding mode set to IEEE-754 default, and clear
	 * all exception flags.
	 */
	fscsr x0, x0
    80001840:	00301073          	fscsr	zero

	/*
	 * Initially, setup stack pointer to
	 * z_interrupt_stacks + CONFIG_ISR_STACK_SIZE
	 */
	la sp, z_interrupt_stacks
    80001844:	00003117          	auipc	sp,0x3
    80001848:	ecc10113          	addi	sp,sp,-308 # 80004710 <z_interrupt_stacks>
	li t0, CONFIG_ISR_STACK_SIZE
    8000184c:	000012b7          	lui	t0,0x1
    80001850:	8002829b          	addiw	t0,t0,-2048
	add sp, sp, t0
    80001854:	00510133          	add	sp,sp,t0

	csrw mscratch, sp
    80001858:	34011073          	csrw	mscratch,sp

	/*
	 * Jump into C domain. _PrepC zeroes BSS, copies rw data into RAM,
	 * and then enters kernel z_cstart
	 */
	call _PrepC
    8000185c:	fb9ff0ef          	jal	ra,80001814 <_PrepC>

0000000080001860 <z_thread_entry_wrapper>:
	 * in registers a0, a1, a2 and a3. These registers are used as arguments
	 * to function z_thread_entry. Hence, just call z_thread_entry with
	 * return address set to 0 to indicate a non-returning function call.
	 */

	jal x0, z_thread_entry
    80001860:	c51fe06f          	j	800004b0 <z_thread_entry>

0000000080001864 <arch_new_thread>:
#ifdef CONFIG_RISCV_SOC_CONTEXT_SAVE
	const struct soc_esf soc_esf_init = {SOC_ESF_INIT};
#endif

	/* Initial stack frame for thread */
	stack_init = (struct __esf *)Z_STACK_PTR_ALIGN(
    80001864:	f6860613          	addi	a2,a2,-152
 * @param ptr Proposed stack pointer address
 * @return Properly aligned stack pointer address
 */
static inline char *z_stack_ptr_align(char *ptr)
{
	return (char *)ROUND_DOWN(ptr, ARCH_STACK_PTR_ALIGN);
    80001868:	ff067613          	andi	a2,a2,-16
				);

	/* Setup the initial stack frame */
	stack_init->a0 = (ulong_t)entry;
	stack_init->a1 = (ulong_t)p1;
	stack_init->a2 = (ulong_t)p2;
    8000186c:	04f63c23          	sd	a5,88(a2)
		stack_init->mstatus |= MSTATUS_FS_INIT;
	}
	stack_init->fp_state = 0;
#elif defined(CONFIG_FPU)
	/* Unshared FP mode: enable FPU of each thread. */
	stack_init->mstatus |= MSTATUS_FS_INIT;
    80001870:	000047b7          	lui	a5,0x4
    80001874:	88078793          	addi	a5,a5,-1920 # 3880 <__rom_region_size+0x638>
    80001878:	08f63823          	sd	a5,144(a2)
#endif

	stack_init->mepc = (ulong_t)z_thread_entry_wrapper;
    8000187c:	00000797          	auipc	a5,0x0
    80001880:	fe478793          	addi	a5,a5,-28 # 80001860 <z_thread_entry_wrapper>
	stack_init->a0 = (ulong_t)entry;
    80001884:	04d63423          	sd	a3,72(a2)
	stack_init->a1 = (ulong_t)p1;
    80001888:	04e63823          	sd	a4,80(a2)
	stack_init->a3 = (ulong_t)p3;
    8000188c:	07063023          	sd	a6,96(a2)
	stack_init->mepc = (ulong_t)z_thread_entry_wrapper;
    80001890:	08f63423          	sd	a5,136(a2)

#ifdef CONFIG_RISCV_SOC_CONTEXT_SAVE
	stack_init->soc_context = soc_esf_init;
#endif

	thread->callee_saved.sp = (ulong_t)stack_init;
    80001894:	04c53423          	sd	a2,72(a0)
}
    80001898:	00008067          	ret

000000008000189c <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
    8000189c:	00050793          	mv	a5,a0
	size_t n = 0;
    800018a0:	00000513          	li	a0,0

	while (*s != '\0') {
    800018a4:	00a78733          	add	a4,a5,a0
    800018a8:	00074703          	lbu	a4,0(a4)
    800018ac:	00071463          	bnez	a4,800018b4 <strlen+0x18>
		s++;
		n++;
	}

	return n;
}
    800018b0:	00008067          	ret
		n++;
    800018b4:	00150513          	addi	a0,a0,1
    800018b8:	fedff06f          	j	800018a4 <strlen+0x8>

00000000800018bc <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
    800018bc:	00050793          	mv	a5,a0
	size_t n = 0;
    800018c0:	00000513          	li	a0,0

	while (*s != '\0' && n < maxlen) {
    800018c4:	00a78733          	add	a4,a5,a0
    800018c8:	00074703          	lbu	a4,0(a4)
    800018cc:	00070463          	beqz	a4,800018d4 <strnlen+0x18>
    800018d0:	00b51463          	bne	a0,a1,800018d8 <strnlen+0x1c>
		s++;
		n++;
	}

	return n;
}
    800018d4:	00008067          	ret
		n++;
    800018d8:	00150513          	addi	a0,a0,1
    800018dc:	fe9ff06f          	j	800018c4 <strnlen+0x8>

00000000800018e0 <memset>:
void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
    800018e0:	0ff5f593          	andi	a1,a1,255
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
    800018e4:	00c50633          	add	a2,a0,a2
	unsigned char *d_byte = (unsigned char *)buf;
    800018e8:	00050793          	mv	a5,a0
	while (n > 0) {
    800018ec:	00c79463          	bne	a5,a2,800018f4 <memset+0x14>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
    800018f0:	00008067          	ret
		*(d_byte++) = c_byte;
    800018f4:	00178793          	addi	a5,a5,1
    800018f8:	feb78fa3          	sb	a1,-1(a5)
		n--;
    800018fc:	ff1ff06f          	j	800018ec <memset+0xc>

0000000080001900 <xlnx_uartlite_read_status>:
	const struct xlnx_uartlite_config *config = dev->config;
	struct xlnx_uartlite_data *data = dev->data;
	uint32_t status;

	/* Cache errors as they are cleared by reading the STAT_REG */
	status = sys_read32(config->base + STAT_REG_OFFSET);
    80001900:	00853783          	ld	a5,8(a0)
	struct xlnx_uartlite_data *data = dev->data;
    80001904:	02053703          	ld	a4,32(a0)
	status = sys_read32(config->base + STAT_REG_OFFSET);
    80001908:	0007b783          	ld	a5,0(a5)
	*(volatile uint16_t *)addr = data;
}

static ALWAYS_INLINE uint32_t sys_read32(mem_addr_t addr)
{
	return *(volatile uint32_t *)addr;
    8000190c:	0087a503          	lw	a0,8(a5)
	data->errors &= (status & STAT_REG_ERROR_MASK);
    80001910:	00072783          	lw	a5,0(a4)
    80001914:	0005051b          	sext.w	a0,a0
    80001918:	00f577b3          	and	a5,a0,a5
    8000191c:	0e07f793          	andi	a5,a5,224
    80001920:	00f72023          	sw	a5,0(a4)

	/* Return current status and previously cached errors */
	return status | data->errors;
}
    80001924:	00f56533          	or	a0,a0,a5
    80001928:	00008067          	ret

000000008000192c <xlnx_uartlite_poll_in>:

	sys_write32((uint32_t)c, config->base + TX_FIFO_OFFSET);
}

static int xlnx_uartlite_poll_in(const struct device *dev, unsigned char *c)
{
    8000192c:	fe010113          	addi	sp,sp,-32
    80001930:	00813823          	sd	s0,16(sp)
    80001934:	00913423          	sd	s1,8(sp)
    80001938:	00113c23          	sd	ra,24(sp)
    8000193c:	00050493          	mv	s1,a0
    80001940:	00058413          	mv	s0,a1
	if (xlnx_uartlite_read_status(dev) & STAT_REG_RX_FIFO_VALID_DATA) {
    80001944:	fbdff0ef          	jal	ra,80001900 <xlnx_uartlite_read_status>
    80001948:	00157513          	andi	a0,a0,1
    8000194c:	02050663          	beqz	a0,80001978 <xlnx_uartlite_poll_in+0x4c>
	return (sys_read32(config->base + RX_FIFO_OFFSET) & BIT_MASK(8));
    80001950:	0084b783          	ld	a5,8(s1)
		*c = xlnx_uartlite_read_rx_fifo(dev);
		return 0;
    80001954:	00000513          	li	a0,0
    80001958:	0007b783          	ld	a5,0(a5)
    8000195c:	0007a783          	lw	a5,0(a5)
	return (sys_read32(config->base + RX_FIFO_OFFSET) & BIT_MASK(8));
    80001960:	00f40023          	sb	a5,0(s0)
	}

	return -1;
}
    80001964:	01813083          	ld	ra,24(sp)
    80001968:	01013403          	ld	s0,16(sp)
    8000196c:	00813483          	ld	s1,8(sp)
    80001970:	02010113          	addi	sp,sp,32
    80001974:	00008067          	ret
	return -1;
    80001978:	fff00513          	li	a0,-1
    8000197c:	fe9ff06f          	j	80001964 <xlnx_uartlite_poll_in+0x38>

0000000080001980 <xlnx_uartlite_err_check>:

	xlnx_uartlite_write_tx_fifo(dev, c);
}

static int xlnx_uartlite_err_check(const struct device *dev)
{
    80001980:	ff010113          	addi	sp,sp,-16
    80001984:	00813023          	sd	s0,0(sp)
    80001988:	00113423          	sd	ra,8(sp)
    8000198c:	00050413          	mv	s0,a0
	uint32_t status = xlnx_uartlite_read_status(dev);
    80001990:	f71ff0ef          	jal	ra,80001900 <xlnx_uartlite_read_status>
	int err = 0;

	if (status & STAT_REG_OVERRUN_ERROR) {
    80001994:	4055579b          	sraiw	a5,a0,0x5
	uint32_t status = xlnx_uartlite_read_status(dev);
    80001998:	0005071b          	sext.w	a4,a0
		err |= UART_ERROR_OVERRUN;
	}

	if (status & STAT_REG_PARITY_ERROR) {
    8000199c:	08057513          	andi	a0,a0,128
		err |= UART_ERROR_OVERRUN;
    800019a0:	0017f793          	andi	a5,a5,1
	if (status & STAT_REG_PARITY_ERROR) {
    800019a4:	00050463          	beqz	a0,800019ac <xlnx_uartlite_err_check+0x2c>
		err |= UART_ERROR_PARITY;
    800019a8:	0027e793          	ori	a5,a5,2
	}

	if (status & STAT_REG_FRAME_ERROR) {
    800019ac:	04077713          	andi	a4,a4,64
    800019b0:	00070463          	beqz	a4,800019b8 <xlnx_uartlite_err_check+0x38>
		err |= UART_ERROR_FRAMING;
    800019b4:	0047e793          	ori	a5,a5,4
	data->errors = 0;
    800019b8:	02043703          	ld	a4,32(s0)
	}

	xlnx_uartlite_clear_status(dev);

	return err;
}
    800019bc:	00813083          	ld	ra,8(sp)
    800019c0:	00013403          	ld	s0,0(sp)
	data->errors = 0;
    800019c4:	00072023          	sw	zero,0(a4)
}
    800019c8:	00078513          	mv	a0,a5
    800019cc:	01010113          	addi	sp,sp,16
    800019d0:	00008067          	ret

00000000800019d4 <xlnx_uartlite_init>:
	k_timer_init(&data->timer, &xlnx_uartlite_tx_soft_isr, NULL);
#endif /* CONFIG_UART_INTERRUPT_DRIVEN */

	/* Reset FIFOs and disable interrupts */
	sys_write32(CTRL_REG_RST_RX_FIFO | CTRL_REG_RST_TX_FIFO,
		    config->base + CTRL_REG_OFFSET);
    800019d4:	00853783          	ld	a5,8(a0)
}

static ALWAYS_INLINE void sys_write32(uint32_t data, mem_addr_t addr)
{
	*(volatile uint32_t *)addr = data;
    800019d8:	00300713          	li	a4,3
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	config->irq_config_func(dev);
#endif /* CONFIG_UART_INTERRUPT_DRIVEN */

	return 0;
}
    800019dc:	00000513          	li	a0,0
	sys_write32(CTRL_REG_RST_RX_FIFO | CTRL_REG_RST_TX_FIFO,
    800019e0:	0007b783          	ld	a5,0(a5)
    800019e4:	00e7a623          	sw	a4,12(a5)
}
    800019e8:	00008067          	ret

00000000800019ec <xlnx_uartlite_poll_out>:
{
    800019ec:	fe010113          	addi	sp,sp,-32
    800019f0:	00813823          	sd	s0,16(sp)
    800019f4:	00913423          	sd	s1,8(sp)
    800019f8:	00113c23          	sd	ra,24(sp)
    800019fc:	00050493          	mv	s1,a0
    80001a00:	00058413          	mv	s0,a1
	while (xlnx_uartlite_read_status(dev) & STAT_REG_TX_FIFO_FULL) {
    80001a04:	00048513          	mv	a0,s1
    80001a08:	ef9ff0ef          	jal	ra,80001900 <xlnx_uartlite_read_status>
    80001a0c:	00857513          	andi	a0,a0,8
    80001a10:	fe051ae3          	bnez	a0,80001a04 <xlnx_uartlite_poll_out+0x18>
	sys_write32((uint32_t)c, config->base + TX_FIFO_OFFSET);
    80001a14:	0084b783          	ld	a5,8(s1)
    80001a18:	0004041b          	sext.w	s0,s0
}
    80001a1c:	01813083          	ld	ra,24(sp)
	sys_write32((uint32_t)c, config->base + TX_FIFO_OFFSET);
    80001a20:	0007b783          	ld	a5,0(a5)
}
    80001a24:	00813483          	ld	s1,8(sp)
    80001a28:	0087a223          	sw	s0,4(a5)
    80001a2c:	01013403          	ld	s0,16(sp)
    80001a30:	02010113          	addi	sp,sp,32
    80001a34:	00008067          	ret

0000000080001a38 <timer_isr>:
    80001a38:	00800793          	li	a5,8
    80001a3c:	3007b7f3          	csrrc	a5,mstatus,a5
}

static uint64_t mtime(void)
{
#ifdef CONFIG_64BIT
	return *(volatile uint64_t *)RISCV_MTIME_BASE;
    80001a40:	0030c737          	lui	a4,0x30c
    80001a44:	ff873683          	ld	a3,-8(a4) # 30bff8 <CONFIG_SRAM_SIZE+0x2fbff8>
{
	ARG_UNUSED(arg);

	k_spinlock_key_t key = k_spin_lock(&lock);
	uint64_t now = mtime();
	uint32_t dticks = (uint32_t)((now - last_count) / CYC_PER_TICK);
    80001a48:	00002717          	auipc	a4,0x2
    80001a4c:	80870713          	addi	a4,a4,-2040 # 80003250 <last_count>
    80001a50:	00073503          	ld	a0,0(a4)
    80001a54:	7d000613          	li	a2,2000

	last_count = now;
    80001a58:	00d73023          	sd	a3,0(a4)
	uint32_t dticks = (uint32_t)((now - last_count) / CYC_PER_TICK);
    80001a5c:	40a68533          	sub	a0,a3,a0
    80001a60:	02c55533          	divu	a0,a0,a2
			  : "=r" (mstatus)
			  : "r" (key & MSTATUS_IEN)
    80001a64:	0087f793          	andi	a5,a5,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
    80001a68:	3007a7f3          	csrrs	a5,mstatus,a5
		}
		set_mtimecmp(next);
	}

	k_spin_unlock(&lock, key);
	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
    80001a6c:	0005051b          	sext.w	a0,a0
    80001a70:	7910006f          	j	80002a00 <sys_clock_announce>

0000000080001a74 <sys_clock_driver_init>:
	return *(volatile uint64_t *)RISCV_MTIME_BASE;
    80001a74:	0030c7b7          	lui	a5,0x30c
    80001a78:	ff87b783          	ld	a5,-8(a5) # 30bff8 <CONFIG_SRAM_SIZE+0x2fbff8>
}

int sys_clock_driver_init(const struct device *dev)
{
    80001a7c:	ff010113          	addi	sp,sp,-16
    80001a80:	00113423          	sd	ra,8(sp)
	ARG_UNUSED(dev);

	IRQ_CONNECT(RISCV_MACHINE_TIMER_IRQ, 0, timer_isr, NULL, 0);
	last_count = mtime();
    80001a84:	00001717          	auipc	a4,0x1
    80001a88:	7cf73623          	sd	a5,1996(a4) # 80003250 <last_count>
	*(volatile uint64_t *)RISCV_MTIMECMP_BASE = time;
    80001a8c:	00304737          	lui	a4,0x304
	set_mtimecmp(last_count + CYC_PER_TICK);
    80001a90:	7d078793          	addi	a5,a5,2000
	irq_enable(RISCV_MACHINE_TIMER_IRQ);
    80001a94:	00700513          	li	a0,7
	*(volatile uint64_t *)RISCV_MTIMECMP_BASE = time;
    80001a98:	00f73023          	sd	a5,0(a4) # 304000 <CONFIG_SRAM_SIZE+0x2f4000>
	irq_enable(RISCV_MACHINE_TIMER_IRQ);
    80001a9c:	d11ff0ef          	jal	ra,800017ac <arch_irq_enable>
	return 0;
}
    80001aa0:	00813083          	ld	ra,8(sp)
    80001aa4:	00000513          	li	a0,0
    80001aa8:	01010113          	addi	sp,sp,16
    80001aac:	00008067          	ret

0000000080001ab0 <sys_clock_set_timeout>:
	 * logic below to reset the comparator, we'll always bump it
	 * forward to the "next tick" due to MIN_DELAY handling and
	 * the interrupt will never fire!  Just rely on the fact that
	 * the OS gave us the proper timeout already.
	 */
	if (idle) {
    80001ab0:	0a059663          	bnez	a1,80001b5c <sys_clock_set_timeout+0xac>
		return;
	}

	ticks = ticks == K_TICKS_FOREVER ? MAX_TICKS : ticks;
    80001ab4:	fff00793          	li	a5,-1
    80001ab8:	00f51663          	bne	a0,a5,80001ac4 <sys_clock_set_timeout+0x14>
    80001abc:	00106537          	lui	a0,0x106
    80001ac0:	24c50513          	addi	a0,a0,588 # 10624c <CONFIG_SRAM_SIZE+0xf624c>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
    80001ac4:	fff5051b          	addiw	a0,a0,-1
    80001ac8:	08a05c63          	blez	a0,80001b60 <sys_clock_set_timeout+0xb0>
    80001acc:	001067b7          	lui	a5,0x106
    80001ad0:	24b78713          	addi	a4,a5,587 # 10624b <CONFIG_SRAM_SIZE+0xf624b>
    80001ad4:	08a74a63          	blt	a4,a0,80001b68 <sys_clock_set_timeout+0xb8>
	__asm__ volatile ("csrrc %0, mstatus, %1"
    80001ad8:	00800693          	li	a3,8
    80001adc:	3006b6f3          	csrrc	a3,mstatus,a3

	k_spinlock_key_t key = k_spin_lock(&lock);
	uint64_t now = mtime();
	uint32_t adj, cyc = ticks * CYC_PER_TICK;
    80001ae0:	7d000713          	li	a4,2000
    80001ae4:	02a7063b          	mulw	a2,a4,a0
	return *(volatile uint64_t *)RISCV_MTIME_BASE;
    80001ae8:	0030c7b7          	lui	a5,0x30c
    80001aec:	ff87b783          	ld	a5,-8(a5) # 30bff8 <CONFIG_SRAM_SIZE+0x2fbff8>

	/* Round up to next tick boundary. */
	adj = (uint32_t)(now - last_count) + (CYC_PER_TICK - 1);
	if (cyc <= MAX_CYC - adj) {
    80001af0:	80000737          	lui	a4,0x80000
	adj = (uint32_t)(now - last_count) + (CYC_PER_TICK - 1);
    80001af4:	00001817          	auipc	a6,0x1
    80001af8:	75c83803          	ld	a6,1884(a6) # 80003250 <last_count>
	if (cyc <= MAX_CYC - adj) {
    80001afc:	fff74713          	not	a4,a4
	adj = (uint32_t)(now - last_count) + (CYC_PER_TICK - 1);
    80001b00:	0007889b          	sext.w	a7,a5
	if (cyc <= MAX_CYC - adj) {
    80001b04:	0107073b          	addw	a4,a4,a6
    80001b08:	7cf7879b          	addiw	a5,a5,1999
    80001b0c:	40f7073b          	subw	a4,a4,a5
	key = (mstatus & MSTATUS_IEN);
    80001b10:	0086f693          	andi	a3,a3,8
	adj = (uint32_t)(now - last_count) + (CYC_PER_TICK - 1);
    80001b14:	0008059b          	sext.w	a1,a6
	if (cyc <= MAX_CYC - adj) {
    80001b18:	04c76c63          	bltu	a4,a2,80001b70 <sys_clock_set_timeout+0xc0>
	adj = (uint32_t)(now - last_count) + (CYC_PER_TICK - 1);
    80001b1c:	40b787bb          	subw	a5,a5,a1
		cyc += adj;
    80001b20:	00c787bb          	addw	a5,a5,a2
	} else {
		cyc = MAX_CYC;
	}
	cyc = (cyc / CYC_PER_TICK) * CYC_PER_TICK;
    80001b24:	7d000613          	li	a2,2000
    80001b28:	02c7d7bb          	divuw	a5,a5,a2

	if ((int32_t)(cyc + last_count - now) < MIN_DELAY) {
    80001b2c:	411585bb          	subw	a1,a1,a7
	cyc = (cyc / CYC_PER_TICK) * CYC_PER_TICK;
    80001b30:	02f6073b          	mulw	a4,a2,a5
	if ((int32_t)(cyc + last_count - now) < MIN_DELAY) {
    80001b34:	3e700613          	li	a2,999
    80001b38:	00e585bb          	addw	a1,a1,a4
    80001b3c:	00b64463          	blt	a2,a1,80001b44 <sys_clock_set_timeout+0x94>
		cyc += CYC_PER_TICK;
    80001b40:	7d07071b          	addiw	a4,a4,2000
	}

	set_mtimecmp(cyc + last_count);
    80001b44:	02071713          	slli	a4,a4,0x20
    80001b48:	02075713          	srli	a4,a4,0x20
    80001b4c:	01070733          	add	a4,a4,a6
	*(volatile uint64_t *)RISCV_MTIMECMP_BASE = time;
    80001b50:	003047b7          	lui	a5,0x304
    80001b54:	00e7b023          	sd	a4,0(a5) # 304000 <CONFIG_SRAM_SIZE+0x2f4000>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    80001b58:	3006a6f3          	csrrs	a3,mstatus,a3
	k_spin_unlock(&lock, key);
#endif
}
    80001b5c:	00008067          	ret
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
    80001b60:	00000513          	li	a0,0
    80001b64:	f75ff06f          	j	80001ad8 <sys_clock_set_timeout+0x28>
    80001b68:	24c78513          	addi	a0,a5,588
    80001b6c:	f6dff06f          	j	80001ad8 <sys_clock_set_timeout+0x28>
		cyc = MAX_CYC;
    80001b70:	800007b7          	lui	a5,0x80000
    80001b74:	fff7c793          	not	a5,a5
    80001b78:	fadff06f          	j	80001b24 <sys_clock_set_timeout+0x74>

0000000080001b7c <sys_clock_elapsed>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
    80001b7c:	00800793          	li	a5,8
    80001b80:	3007b7f3          	csrrc	a5,mstatus,a5
	return *(volatile uint64_t *)RISCV_MTIME_BASE;
    80001b84:	0030c737          	lui	a4,0x30c
    80001b88:	ff873503          	ld	a0,-8(a4) # 30bff8 <CONFIG_SRAM_SIZE+0x2fbff8>
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	uint32_t ret = ((uint32_t)mtime() - (uint32_t)last_count) / CYC_PER_TICK;
    80001b8c:	00001717          	auipc	a4,0x1
    80001b90:	6c473703          	ld	a4,1732(a4) # 80003250 <last_count>
			  : "r" (key & MSTATUS_IEN)
    80001b94:	0087f793          	andi	a5,a5,8
    80001b98:	40e5053b          	subw	a0,a0,a4
    80001b9c:	7d000713          	li	a4,2000
    80001ba0:	02e5553b          	divuw	a0,a0,a4
	__asm__ volatile ("csrrs %0, mstatus, %1"
    80001ba4:	3007a7f3          	csrrs	a5,mstatus,a5

	k_spin_unlock(&lock, key);
	return ret;
}
    80001ba8:	00008067          	ret

0000000080001bac <arch_system_halt>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
    80001bac:	00800793          	li	a5,8
    80001bb0:	3007b7f3          	csrrc	a5,mstatus,a5
	/* TODO: What's the best way to totally halt the system if SMP
	 * is enabled?
	 */

	(void)arch_irq_lock();
	for (;;) {
    80001bb4:	0000006f          	j	80001bb4 <arch_system_halt+0x8>

0000000080001bb8 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
    80001bb8:	ff010113          	addi	sp,sp,-16
    80001bbc:	00113423          	sd	ra,8(sp)
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
	arch_system_halt(reason);
    80001bc0:	fedff0ef          	jal	ra,80001bac <arch_system_halt>

0000000080001bc4 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    80001bc4:	fd010113          	addi	sp,sp,-48
    80001bc8:	02813023          	sd	s0,32(sp)
    80001bcc:	01213823          	sd	s2,16(sp)
    80001bd0:	02113423          	sd	ra,40(sp)
    80001bd4:	00913c23          	sd	s1,24(sp)
    80001bd8:	00050913          	mv	s2,a0
    80001bdc:	00b13423          	sd	a1,8(sp)
    80001be0:	00800413          	li	s0,8
    80001be4:	30043473          	csrrc	s0,mstatus,s0
	return z_impl_z_current_get();
    80001be8:	1d9000ef          	jal	ra,800025c0 <z_impl_z_current_get>
	LOG_ERR("Current thread: %p (%s)", thread,
		log_strdup(thread_name_get(thread)));

	coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
    80001bec:	00813583          	ld	a1,8(sp)
    80001bf0:	00050493          	mv	s1,a0
    80001bf4:	00090513          	mv	a0,s2
    80001bf8:	fc1ff0ef          	jal	ra,80001bb8 <k_sys_fatal_error_handler>
			  : "r" (key & MSTATUS_IEN)
    80001bfc:	00847413          	andi	s0,s0,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
    80001c00:	30042473          	csrrs	s0,mstatus,s0
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
    80001c04:	02013403          	ld	s0,32(sp)
    80001c08:	02813083          	ld	ra,40(sp)
    80001c0c:	01013903          	ld	s2,16(sp)
	z_impl_k_thread_abort(thread);
    80001c10:	00048513          	mv	a0,s1
    80001c14:	01813483          	ld	s1,24(sp)
    80001c18:	03010113          	addi	sp,sp,48
    80001c1c:	2a50006f          	j	800026c0 <z_impl_k_thread_abort>

0000000080001c20 <init_idle_thread>:

#if defined(CONFIG_MULTITHREADING)
__boot_func
static void init_idle_thread(int i)
{
	struct k_thread *thread = &z_idle_threads[i];
    80001c20:	0f800793          	li	a5,248
#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
    80001c24:	02800713          	li	a4,40
    80001c28:	02e50733          	mul	a4,a0,a4
	k_thread_stack_t *stack = z_idle_stacks[i];
    80001c2c:	00951593          	slli	a1,a0,0x9
{
    80001c30:	fe010113          	addi	sp,sp,-32
    80001c34:	00813823          	sd	s0,16(sp)
	struct k_thread *thread = &z_idle_threads[i];
    80001c38:	00001417          	auipc	s0,0x1
    80001c3c:	6e840413          	addi	s0,s0,1768 # 80003320 <z_idle_threads>
	z_setup_new_thread(thread, stack,
    80001c40:	00001697          	auipc	a3,0x1
    80001c44:	6a068693          	addi	a3,a3,1696 # 800032e0 <_kernel>
    80001c48:	00013423          	sd	zero,8(sp)
    80001c4c:	00f00893          	li	a7,15
    80001c50:	00000813          	li	a6,0
    80001c54:	20000613          	li	a2,512
	struct k_thread *thread = &z_idle_threads[i];
    80001c58:	02f50533          	mul	a0,a0,a5
	z_setup_new_thread(thread, stack,
    80001c5c:	00100793          	li	a5,1
    80001c60:	00f13023          	sd	a5,0(sp)
    80001c64:	00e68733          	add	a4,a3,a4
    80001c68:	00000793          	li	a5,0
    80001c6c:	00000697          	auipc	a3,0x0
    80001c70:	37c68693          	addi	a3,a3,892 # 80001fe8 <idle>
{
    80001c74:	00113c23          	sd	ra,24(sp)
	struct k_thread *thread = &z_idle_threads[i];
    80001c78:	00a40433          	add	s0,s0,a0
	z_setup_new_thread(thread, stack,
    80001c7c:	00003517          	auipc	a0,0x3
    80001c80:	89450513          	addi	a0,a0,-1900 # 80004510 <z_idle_stacks>
    80001c84:	00b505b3          	add	a1,a0,a1
    80001c88:	00040513          	mv	a0,s0
    80001c8c:	1d0000ef          	jal	ra,80001e5c <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
    80001c90:	01944783          	lbu	a5,25(s0)
	z_mark_thread_as_started(thread);

#ifdef CONFIG_SMP
	thread->base.is_idle = 1U;
#endif
}
    80001c94:	01813083          	ld	ra,24(sp)
    80001c98:	ffb7f793          	andi	a5,a5,-5
    80001c9c:	00f40ca3          	sb	a5,25(s0)
    80001ca0:	01013403          	ld	s0,16(sp)
    80001ca4:	02010113          	addi	sp,sp,32
    80001ca8:	00008067          	ret

0000000080001cac <bg_thread_main>:
{
    80001cac:	ff010113          	addi	sp,sp,-16
	z_sys_post_kernel = true;
    80001cb0:	00100793          	li	a5,1
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    80001cb4:	00200513          	li	a0,2
{
    80001cb8:	00113423          	sd	ra,8(sp)
	z_sys_post_kernel = true;
    80001cbc:	00001717          	auipc	a4,0x1
    80001cc0:	5af70c23          	sb	a5,1464(a4) # 80003274 <z_sys_post_kernel>
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    80001cc4:	655000ef          	jal	ra,80002b18 <z_sys_init_run_level>
	boot_banner();
    80001cc8:	649000ef          	jal	ra,80002b10 <boot_banner>
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
    80001ccc:	00300513          	li	a0,3
    80001cd0:	649000ef          	jal	ra,80002b18 <z_sys_init_run_level>
	z_init_static_threads();
    80001cd4:	224000ef          	jal	ra,80001ef8 <z_init_static_threads>
	main();
    80001cd8:	e18fe0ef          	jal	ra,800002f0 <main>
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
    80001cdc:	00001717          	auipc	a4,0x1
    80001ce0:	73c70713          	addi	a4,a4,1852 # 80003418 <z_main_thread>
    80001ce4:	01874783          	lbu	a5,24(a4)
    80001ce8:	ffe7f793          	andi	a5,a5,-2
    80001cec:	00f70c23          	sb	a5,24(a4)
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
    80001cf0:	00813083          	ld	ra,8(sp)
    80001cf4:	01010113          	addi	sp,sp,16
    80001cf8:	00008067          	ret

0000000080001cfc <z_bss_zero>:
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
    80001cfc:	00001517          	auipc	a0,0x1
    80001d00:	54c50513          	addi	a0,a0,1356 # 80003248 <xlnx_uartlite_0_data>
    80001d04:	00002617          	auipc	a2,0x2
    80001d08:	80c60613          	addi	a2,a2,-2036 # 80003510 <z_main_stack>
    80001d0c:	40a60633          	sub	a2,a2,a0
    80001d10:	00000593          	li	a1,0
    80001d14:	bcdff06f          	j	800018e0 <memset>

0000000080001d18 <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
    80001d18:	ed010113          	addi	sp,sp,-304
{
	dummy_thread->base.thread_state = _THREAD_DUMMY;
#ifdef CONFIG_SCHED_CPU_MASK
	dummy_thread->base.cpu_mask = -1;
#endif
	dummy_thread->base.user_options = K_ESSENTIAL;
    80001d1c:	10100793          	li	a5,257
    80001d20:	12113423          	sd	ra,296(sp)
    80001d24:	12813023          	sd	s0,288(sp)
    80001d28:	10913c23          	sd	s1,280(sp)
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
    80001d2c:	00001417          	auipc	s0,0x1
    80001d30:	5b440413          	addi	s0,s0,1460 # 800032e0 <_kernel>
	dummy_thread->base.user_options = K_ESSENTIAL;
    80001d34:	02f11823          	sh	a5,48(sp)
	_current_cpu->current = dummy_thread;
    80001d38:	01810793          	addi	a5,sp,24
    80001d3c:	00f43823          	sd	a5,16(s0)
	dummy_thread->stack_info.start = 0U;
    80001d40:	0e013423          	sd	zero,232(sp)
	dummy_thread->stack_info.size = 0U;
    80001d44:	0e013823          	sd	zero,240(sp)
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
    80001d48:	5cd000ef          	jal	ra,80002b14 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    80001d4c:	00000513          	li	a0,0
    80001d50:	5c9000ef          	jal	ra,80002b18 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    80001d54:	00100513          	li	a0,1
    80001d58:	5c1000ef          	jal	ra,80002b18 <z_sys_init_run_level>
	_kernel.ready_q.cache = &z_main_thread;
    80001d5c:	00001497          	auipc	s1,0x1
    80001d60:	6bc48493          	addi	s1,s1,1724 # 80003418 <z_main_thread>
	z_sched_init();
    80001d64:	039000ef          	jal	ra,8000259c <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    80001d68:	00001797          	auipc	a5,0x1
    80001d6c:	35078793          	addi	a5,a5,848 # 800030b8 <xlnx_uartlite_driver_api+0x38>
	_kernel.ready_q.cache = &z_main_thread;
    80001d70:	02943423          	sd	s1,40(s0)
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    80001d74:	00f13423          	sd	a5,8(sp)
    80001d78:	00100793          	li	a5,1
    80001d7c:	00000893          	li	a7,0
    80001d80:	00000813          	li	a6,0
    80001d84:	00000713          	li	a4,0
    80001d88:	00000697          	auipc	a3,0x0
    80001d8c:	f2468693          	addi	a3,a3,-220 # 80001cac <bg_thread_main>
    80001d90:	00001637          	lui	a2,0x1
    80001d94:	00001597          	auipc	a1,0x1
    80001d98:	77c58593          	addi	a1,a1,1916 # 80003510 <z_main_stack>
    80001d9c:	00f13023          	sd	a5,0(sp)
    80001da0:	00048513          	mv	a0,s1
    80001da4:	00000793          	li	a5,0
    80001da8:	0b4000ef          	jal	ra,80001e5c <z_setup_new_thread>
    80001dac:	0194c783          	lbu	a5,25(s1)
	z_ready_thread(&z_main_thread);
    80001db0:	00048513          	mv	a0,s1
    80001db4:	ffb7f793          	andi	a5,a5,-5
    80001db8:	00f48ca3          	sb	a5,25(s1)
    80001dbc:	69c000ef          	jal	ra,80002458 <z_ready_thread>
		init_idle_thread(i);
    80001dc0:	00000513          	li	a0,0
    80001dc4:	e5dff0ef          	jal	ra,80001c20 <init_idle_thread>
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
    80001dc8:	00001797          	auipc	a5,0x1
    80001dcc:	55878793          	addi	a5,a5,1368 # 80003320 <z_idle_threads>
    80001dd0:	00f43c23          	sd	a5,24(s0)
		_kernel.cpus[i].irq_stack =
    80001dd4:	00003797          	auipc	a5,0x3
    80001dd8:	13c78793          	addi	a5,a5,316 # 80004f10 <timeout_list>
		_kernel.cpus[i].id = i;
    80001ddc:	02040223          	sb	zero,36(s0)
		_kernel.cpus[i].irq_stack =
    80001de0:	00f43423          	sd	a5,8(s0)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    80001de4:	00800413          	li	s0,8
    80001de8:	30043473          	csrrc	s0,mstatus,s0
	z_check_stack_sentinel();
    80001dec:	00c000ef          	jal	ra,80001df8 <z_check_stack_sentinel>
	ret = arch_swap(key);
    80001df0:	00847513          	andi	a0,s0,8
    80001df4:	cd4fe0ef          	jal	ra,800002c8 <arch_swap>

0000000080001df8 <z_check_stack_sentinel>:
 */
void z_check_stack_sentinel(void)
{
	uint32_t *stack;

	if ((_current->base.thread_state & _THREAD_DUMMY) != 0) {
    80001df8:	00001717          	auipc	a4,0x1
    80001dfc:	4f873703          	ld	a4,1272(a4) # 800032f0 <_kernel+0x10>
    80001e00:	01974783          	lbu	a5,25(a4)
    80001e04:	0017f793          	andi	a5,a5,1
    80001e08:	04079863          	bnez	a5,80001e58 <z_check_stack_sentinel+0x60>
		return;
	}

	stack = (uint32_t *)_current->stack_info.start;
    80001e0c:	0d073703          	ld	a4,208(a4)
	if (*stack != STACK_SENTINEL) {
    80001e10:	f0f0f7b7          	lui	a5,0xf0f0f
    80001e14:	0f078793          	addi	a5,a5,240 # fffffffff0f0f0f0 <__data_region_end+0xffffffff70f0a1bc>
    80001e18:	00072683          	lw	a3,0(a4)
    80001e1c:	02f68e63          	beq	a3,a5,80001e58 <z_check_stack_sentinel+0x60>
{
    80001e20:	ff010113          	addi	sp,sp,-16
    80001e24:	00113423          	sd	ra,8(sp)
		/* Restore it so further checks don't trigger this same error */
		*stack = STACK_SENTINEL;
		z_except_reason(K_ERR_STACK_CHK_FAIL);
    80001e28:	00001597          	auipc	a1,0x1
    80001e2c:	29858593          	addi	a1,a1,664 # 800030c0 <xlnx_uartlite_driver_api+0x40>
    80001e30:	00001517          	auipc	a0,0x1
    80001e34:	2b850513          	addi	a0,a0,696 # 800030e8 <xlnx_uartlite_driver_api+0x68>
		*stack = STACK_SENTINEL;
    80001e38:	00f72023          	sw	a5,0(a4)
		z_except_reason(K_ERR_STACK_CHK_FAIL);
    80001e3c:	16500613          	li	a2,357
    80001e40:	e34fe0ef          	jal	ra,80000474 <printk>
	}
}
    80001e44:	00813083          	ld	ra,8(sp)
		z_except_reason(K_ERR_STACK_CHK_FAIL);
    80001e48:	00000593          	li	a1,0
    80001e4c:	00200513          	li	a0,2
}
    80001e50:	01010113          	addi	sp,sp,16
		z_except_reason(K_ERR_STACK_CHK_FAIL);
    80001e54:	d71ff06f          	j	80001bc4 <z_fatal_error>
    80001e58:	00008067          	ret

0000000080001e5c <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
    80001e5c:	fe010113          	addi	sp,sp,-32
    80001e60:	00813823          	sd	s0,16(sp)
    80001e64:	00913423          	sd	s1,8(sp)
    80001e68:	00113c23          	sd	ra,24(sp)
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
    80001e6c:	0b850e13          	addi	t3,a0,184
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
    80001e70:	0bc53c23          	sd	t3,184(a0)
	list->tail = (sys_dnode_t *)list;
    80001e74:	0dc53023          	sd	t3,192(a0)
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
    80001e78:	02012e03          	lw	t3,32(sp)
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    80001e7c:	00f60613          	addi	a2,a2,15 # 100f <CONFIG_MAIN_STACK_SIZE+0xf>
	thread_base->thread_state = (uint8_t)initial_state;

	thread_base->prio = priority;
    80001e80:	01150d23          	sb	a7,26(a0)
	thread_base->user_options = (uint8_t)options;
    80001e84:	01c50c23          	sb	t3,24(a0)
	thread_base->thread_state = (uint8_t)initial_state;
    80001e88:	00400e13          	li	t3,4
    80001e8c:	01c50ca3          	sb	t3,25(a0)
	*((uint32_t *)stack_buf_start) = STACK_SENTINEL;
    80001e90:	f0f0fe37          	lui	t3,0xf0f0f
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    80001e94:	ff067893          	andi	a7,a2,-16
	thread_base->pended_on = NULL;
    80001e98:	00053823          	sd	zero,16(a0)

	thread_base->sched_locked = 0U;
    80001e9c:	00050da3          	sb	zero,27(a0)
 * @return N/A
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
    80001ea0:	02053423          	sd	zero,40(a0)
	node->prev = NULL;
    80001ea4:	02053823          	sd	zero,48(a0)
	*((uint32_t *)stack_buf_start) = STACK_SENTINEL;
    80001ea8:	0f0e0e13          	addi	t3,t3,240 # fffffffff0f0f0f0 <__data_region_end+0xffffffff70f0a1bc>
	stack_ptr = (char *)stack + stack_obj_size;
    80001eac:	011584b3          	add	s1,a1,a7
	*((uint32_t *)stack_buf_start) = STACK_SENTINEL;
    80001eb0:	01c5a023          	sw	t3,0(a1)
	new_thread->stack_info.start = (uintptr_t)stack_buf_start;
    80001eb4:	0cb53823          	sd	a1,208(a0)
	new_thread->stack_info.size = stack_buf_size;
    80001eb8:	0d153c23          	sd	a7,216(a0)
	new_thread->stack_info.delta = delta;
    80001ebc:	0e053023          	sd	zero,224(a0)
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    80001ec0:	00048613          	mv	a2,s1
{
    80001ec4:	00050413          	mv	s0,a0
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    80001ec8:	99dff0ef          	jal	ra,80001864 <arch_new_thread>
	new_thread->resource_pool = _current->resource_pool;
    80001ecc:	00001797          	auipc	a5,0x1
    80001ed0:	4247b783          	ld	a5,1060(a5) # 800032f0 <_kernel+0x10>
    80001ed4:	0e87b783          	ld	a5,232(a5)
}
    80001ed8:	01813083          	ld	ra,24(sp)
	new_thread->init_data = NULL;
    80001edc:	0a043823          	sd	zero,176(s0)
	new_thread->resource_pool = _current->resource_pool;
    80001ee0:	0ef43423          	sd	a5,232(s0)
}
    80001ee4:	01013403          	ld	s0,16(sp)
    80001ee8:	00048513          	mv	a0,s1
    80001eec:	00813483          	ld	s1,8(sp)
    80001ef0:	02010113          	addi	sp,sp,32
    80001ef4:	00008067          	ret

0000000080001ef8 <z_init_static_threads>:
{
    80001ef8:	fc010113          	addi	sp,sp,-64
    80001efc:	02813823          	sd	s0,48(sp)
    80001f00:	02913423          	sd	s1,40(sp)
    80001f04:	02113c23          	sd	ra,56(sp)
    80001f08:	03213023          	sd	s2,32(sp)
    80001f0c:	01313c23          	sd	s3,24(sp)
    80001f10:	01413823          	sd	s4,16(sp)
	_FOREACH_STATIC_THREAD(thread_data) {
    80001f14:	00003417          	auipc	s0,0x3
    80001f18:	02040413          	addi	s0,s0,32 # 80004f34 <__data_region_end>
    80001f1c:	00003497          	auipc	s1,0x3
    80001f20:	01848493          	addi	s1,s1,24 # 80004f34 <__data_region_end>
    80001f24:	04946263          	bltu	s0,s1,80001f68 <z_init_static_threads+0x70>
	k_sched_lock();
    80001f28:	274000ef          	jal	ra,8000219c <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
    80001f2c:	00003417          	auipc	s0,0x3
    80001f30:	00840413          	addi	s0,s0,8 # 80004f34 <__data_region_end>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
    80001f34:	fff00913          	li	s2,-1
		}
	} else if (mul_ratio) {
		if (result32) {
			return ((uint32_t)t) * (to_hz / from_hz);
		} else {
			return t * ((uint64_t)to_hz / from_hz);
    80001f38:	00a00993          	li	s3,10

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    80001f3c:	00000a17          	auipc	s4,0x0
    80001f40:	5aca0a13          	addi	s4,s4,1452 # 800024e8 <z_thread_timeout>
	_FOREACH_STATIC_THREAD(thread_data) {
    80001f44:	06946463          	bltu	s0,s1,80001fac <z_init_static_threads+0xb4>
}
    80001f48:	03013403          	ld	s0,48(sp)
    80001f4c:	03813083          	ld	ra,56(sp)
    80001f50:	02813483          	ld	s1,40(sp)
    80001f54:	02013903          	ld	s2,32(sp)
    80001f58:	01813983          	ld	s3,24(sp)
    80001f5c:	01013a03          	ld	s4,16(sp)
    80001f60:	04010113          	addi	sp,sp,64
	k_sched_unlock();
    80001f64:	5f00006f          	j	80002554 <k_sched_unlock>
		z_setup_new_thread(
    80001f68:	05043783          	ld	a5,80(s0)
    80001f6c:	03842883          	lw	a7,56(s0)
    80001f70:	03043803          	ld	a6,48(s0)
    80001f74:	00f13423          	sd	a5,8(sp)
    80001f78:	03c42783          	lw	a5,60(s0)
    80001f7c:	02043703          	ld	a4,32(s0)
    80001f80:	01843683          	ld	a3,24(s0)
    80001f84:	01046603          	lwu	a2,16(s0)
    80001f88:	00843583          	ld	a1,8(s0)
    80001f8c:	00043503          	ld	a0,0(s0)
    80001f90:	00f13023          	sd	a5,0(sp)
    80001f94:	02843783          	ld	a5,40(s0)
    80001f98:	ec5ff0ef          	jal	ra,80001e5c <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
    80001f9c:	00043783          	ld	a5,0(s0)
    80001fa0:	0a87b823          	sd	s0,176(a5)
	_FOREACH_STATIC_THREAD(thread_data) {
    80001fa4:	05840413          	addi	s0,s0,88
    80001fa8:	f7dff06f          	j	80001f24 <z_init_static_threads+0x2c>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
    80001fac:	04042783          	lw	a5,64(s0)
    80001fb0:	03278063          	beq	a5,s2,80001fd0 <z_init_static_threads+0xd8>
			schedule_new_thread(thread_data->init_thread,
    80001fb4:	00043503          	ld	a0,0(s0)
					    K_MSEC(thread_data->init_delay));
    80001fb8:	0007861b          	sext.w	a2,a5
    80001fbc:	0007d463          	bgez	a5,80001fc4 <z_init_static_threads+0xcc>
    80001fc0:	00000613          	li	a2,0
    80001fc4:	03360633          	mul	a2,a2,s3
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    80001fc8:	00061863          	bnez	a2,80001fd8 <z_init_static_threads+0xe0>
	z_sched_start(thread);
    80001fcc:	4bc000ef          	jal	ra,80002488 <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
    80001fd0:	05840413          	addi	s0,s0,88
    80001fd4:	f71ff06f          	j	80001f44 <z_init_static_threads+0x4c>
    80001fd8:	000a0593          	mv	a1,s4
    80001fdc:	02850513          	addi	a0,a0,40
    80001fe0:	051000ef          	jal	ra,80002830 <z_add_timeout>
    80001fe4:	fedff06f          	j	80001fd0 <z_init_static_threads+0xd8>

0000000080001fe8 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
    80001fe8:	ff010113          	addi	sp,sp,-16
    80001fec:	00813023          	sd	s0,0(sp)
    80001ff0:	00113423          	sd	ra,8(sp)
    80001ff4:	00800413          	li	s0,8
    80001ff8:	300437f3          	csrrc	a5,mstatus,s0
 *
 * @return N/A
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
    80001ffc:	f8cff0ef          	jal	ra,80001788 <arch_cpu_idle>
    80002000:	ff9ff06f          	j	80001ff8 <idle+0x10>

0000000080002004 <sys_dlist_remove>:
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
    80002004:	00853703          	ld	a4,8(a0)
	sys_dnode_t *const next = node->next;
    80002008:	00053783          	ld	a5,0(a0)

	prev->next = next;
    8000200c:	00f73023          	sd	a5,0(a4)
	next->prev = prev;
    80002010:	00e7b423          	sd	a4,8(a5)
	node->next = NULL;
    80002014:	00053023          	sd	zero,0(a0)
	node->prev = NULL;
    80002018:	00053423          	sd	zero,8(a0)
	sys_dnode_init(node);
}
    8000201c:	00008067          	ret

0000000080002020 <unpend_thread_no_timeout>:
	__ASSERT_NO_MSG(thread == _current || is_thread_dummy(thread));
	pend(thread, wait_q, timeout);
}

static inline void unpend_thread_no_timeout(struct k_thread *thread)
{
    80002020:	ff010113          	addi	sp,sp,-16
    80002024:	00813023          	sd	s0,0(sp)
    80002028:	00113423          	sd	ra,8(sp)
    8000202c:	00050413          	mv	s0,a0

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
    80002030:	fd5ff0ef          	jal	ra,80002004 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_PENDING;
}

static inline void z_mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PENDING;
    80002034:	01944783          	lbu	a5,25(s0)
}
    80002038:	00813083          	ld	ra,8(sp)
	thread->base.pended_on = NULL;
    8000203c:	00043823          	sd	zero,16(s0)
    80002040:	ffd7f793          	andi	a5,a5,-3
    80002044:	00f40ca3          	sb	a5,25(s0)
}
    80002048:	00013403          	ld	s0,0(sp)
    8000204c:	01010113          	addi	sp,sp,16
    80002050:	00008067          	ret

0000000080002054 <z_swap_irqlock>:
{
    80002054:	fe010113          	addi	sp,sp,-32
    80002058:	00113c23          	sd	ra,24(sp)
    8000205c:	00a13423          	sd	a0,8(sp)
	z_check_stack_sentinel();
    80002060:	d99ff0ef          	jal	ra,80001df8 <z_check_stack_sentinel>
	ret = arch_swap(key);
    80002064:	00813503          	ld	a0,8(sp)
}
    80002068:	01813083          	ld	ra,24(sp)
    8000206c:	02010113          	addi	sp,sp,32
	ret = arch_swap(key);
    80002070:	a58fe06f          	j	800002c8 <arch_swap>

0000000080002074 <z_reset_time_slice>:
{
    80002074:	ff010113          	addi	sp,sp,-16
    80002078:	00813023          	sd	s0,0(sp)
	if (slice_time != 0) {
    8000207c:	00001417          	auipc	s0,0x1
    80002080:	1f040413          	addi	s0,s0,496 # 8000326c <slice_time>
    80002084:	00042783          	lw	a5,0(s0)
{
    80002088:	00113423          	sd	ra,8(sp)
	if (slice_time != 0) {
    8000208c:	02078863          	beqz	a5,800020bc <z_reset_time_slice+0x48>
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    80002090:	aedff0ef          	jal	ra,80001b7c <sys_clock_elapsed>
    80002094:	00050793          	mv	a5,a0
    80002098:	00042503          	lw	a0,0(s0)
}
    8000209c:	00013403          	ld	s0,0(sp)
    800020a0:	00813083          	ld	ra,8(sp)
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    800020a4:	00a787bb          	addw	a5,a5,a0
    800020a8:	00001717          	auipc	a4,0x1
    800020ac:	24f72c23          	sw	a5,600(a4) # 80003300 <_kernel+0x20>
		z_set_timeout_expiry(slice_time, false);
    800020b0:	00000593          	li	a1,0
}
    800020b4:	01010113          	addi	sp,sp,16
		z_set_timeout_expiry(slice_time, false);
    800020b8:	0f10006f          	j	800029a8 <z_set_timeout_expiry>
}
    800020bc:	00813083          	ld	ra,8(sp)
    800020c0:	00013403          	ld	s0,0(sp)
    800020c4:	01010113          	addi	sp,sp,16
    800020c8:	00008067          	ret

00000000800020cc <k_sched_time_slice_set>:
{
    800020cc:	ff010113          	addi	sp,sp,-16
    800020d0:	00813023          	sd	s0,0(sp)
    800020d4:	00113423          	sd	ra,8(sp)
    800020d8:	00800413          	li	s0,8
    800020dc:	30043473          	csrrc	s0,mstatus,s0
		_current_cpu->slice_ticks = 0;
    800020e0:	00001797          	auipc	a5,0x1
    800020e4:	2207a023          	sw	zero,544(a5) # 80003300 <_kernel+0x20>
			return ((uint32_t)t) * (to_hz / from_hz);
    800020e8:	00a00793          	li	a5,10
    800020ec:	02a787bb          	mulw	a5,a5,a0
	key = (mstatus & MSTATUS_IEN);
    800020f0:	00847413          	andi	s0,s0,8
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
    800020f4:	00001717          	auipc	a4,0x1
    800020f8:	17870713          	addi	a4,a4,376 # 8000326c <slice_time>
    800020fc:	02a04463          	bgtz	a0,80002124 <k_sched_time_slice_set+0x58>
			slice_time = MAX(2, slice_time);
    80002100:	00f72023          	sw	a5,0(a4)
		slice_max_prio = prio;
    80002104:	00001797          	auipc	a5,0x1
    80002108:	16b7a223          	sw	a1,356(a5) # 80003268 <slice_max_prio>
		z_reset_time_slice();
    8000210c:	f69ff0ef          	jal	ra,80002074 <z_reset_time_slice>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    80002110:	30042473          	csrrs	s0,mstatus,s0
}
    80002114:	00813083          	ld	ra,8(sp)
    80002118:	00013403          	ld	s0,0(sp)
    8000211c:	01010113          	addi	sp,sp,16
    80002120:	00008067          	ret
			slice_time = MAX(2, slice_time);
    80002124:	0007861b          	sext.w	a2,a5
    80002128:	00200693          	li	a3,2
    8000212c:	fcd65ae3          	bge	a2,a3,80002100 <k_sched_time_slice_set+0x34>
    80002130:	00200793          	li	a5,2
    80002134:	fcdff06f          	j	80002100 <k_sched_time_slice_set+0x34>

0000000080002138 <z_reschedule>:
	if (resched(key.key) && need_swap()) {
    80002138:	0005851b          	sext.w	a0,a1
	 * have the single bit set).  But there is a mask applied to
	 * the argument in arch_irq_unlock() that has me worried
	 * that something elseswhere might try to set a bit?  Do it
	 * the safe way for now.
	 */
	return (key & MSTATUS_IEN) == MSTATUS_IEN;
    8000213c:	0085f593          	andi	a1,a1,8
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    80002140:	02058263          	beqz	a1,80002164 <z_reschedule+0x2c>
FUNC_NORETURN void z_riscv_fatal_error(unsigned int reason,
				       const z_arch_esf_t *esf);

static inline bool arch_is_in_isr(void)
{
	return _kernel.cpus[0].nested != 0U;
    80002144:	00001797          	auipc	a5,0x1
    80002148:	19c78793          	addi	a5,a5,412 # 800032e0 <_kernel>
	if (resched(key.key) && need_swap()) {
    8000214c:	0007a703          	lw	a4,0(a5)
    80002150:	00071a63          	bnez	a4,80002164 <z_reschedule+0x2c>
    80002154:	0287b703          	ld	a4,40(a5)
    80002158:	0107b783          	ld	a5,16(a5)
    8000215c:	00f70463          	beq	a4,a5,80002164 <z_reschedule+0x2c>
	return z_swap_irqlock(key.key);
    80002160:	ef5ff06f          	j	80002054 <z_swap_irqlock>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    80002164:	3005a5f3          	csrrs	a1,mstatus,a1
}
    80002168:	00008067          	ret

000000008000216c <z_reschedule_irqlock>:
	return (key & MSTATUS_IEN) == MSTATUS_IEN;
    8000216c:	00857793          	andi	a5,a0,8
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    80002170:	00078a63          	beqz	a5,80002184 <z_reschedule_irqlock+0x18>
	if (resched(key)) {
    80002174:	00001717          	auipc	a4,0x1
    80002178:	16c72703          	lw	a4,364(a4) # 800032e0 <_kernel>
    8000217c:	00071463          	bnez	a4,80002184 <z_reschedule_irqlock+0x18>
		z_swap_irqlock(key);
    80002180:	ed5ff06f          	j	80002054 <z_swap_irqlock>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    80002184:	3007a7f3          	csrrs	a5,mstatus,a5
}
    80002188:	00008067          	ret

000000008000218c <z_reschedule_unlocked>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
    8000218c:	00800513          	li	a0,8
    80002190:	30053573          	csrrc	a0,mstatus,a0
	(void) z_reschedule_irqlock(arch_irq_lock());
    80002194:	00857513          	andi	a0,a0,8
    80002198:	fd5ff06f          	j	8000216c <z_reschedule_irqlock>

000000008000219c <k_sched_lock>:
    8000219c:	00800793          	li	a5,8
    800021a0:	3007b7f3          	csrrc	a5,mstatus,a5
static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
    800021a4:	00001697          	auipc	a3,0x1
    800021a8:	14c6b683          	ld	a3,332(a3) # 800032f0 <_kernel+0x10>
    800021ac:	01b6c703          	lbu	a4,27(a3)
    800021b0:	fff7071b          	addiw	a4,a4,-1
    800021b4:	00e68da3          	sb	a4,27(a3)
			  : "r" (key & MSTATUS_IEN)
    800021b8:	0087f793          	andi	a5,a5,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
    800021bc:	3007a7f3          	csrrs	a5,mstatus,a5
}
    800021c0:	00008067          	ret

00000000800021c4 <z_priq_dumb_best>:
}

struct k_thread *z_priq_dumb_best(sys_dlist_t *pq)
{
    800021c4:	00050793          	mv	a5,a0
	return list->head == list;
    800021c8:	00053503          	ld	a0,0(a0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
    800021cc:	00a79463          	bne	a5,a0,800021d4 <z_priq_dumb_best+0x10>
	struct k_thread *thread = NULL;
    800021d0:	00000513          	li	a0,0

	if (n != NULL) {
		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
	}
	return thread;
}
    800021d4:	00008067          	ret

00000000800021d8 <update_cache>:
{
    800021d8:	fe010113          	addi	sp,sp,-32
    800021dc:	01213023          	sd	s2,0(sp)
    800021e0:	00050913          	mv	s2,a0
	return _priq_run_best(curr_cpu_runq());
    800021e4:	00001517          	auipc	a0,0x1
    800021e8:	12c50513          	addi	a0,a0,300 # 80003310 <_kernel+0x30>
{
    800021ec:	00813823          	sd	s0,16(sp)
    800021f0:	00913423          	sd	s1,8(sp)
    800021f4:	00113c23          	sd	ra,24(sp)
	return _priq_run_best(curr_cpu_runq());
    800021f8:	fcdff0ef          	jal	ra,800021c4 <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
    800021fc:	00001497          	auipc	s1,0x1
    80002200:	0e448493          	addi	s1,s1,228 # 800032e0 <_kernel>
    80002204:	00050413          	mv	s0,a0
    80002208:	00051463          	bnez	a0,80002210 <update_cache+0x38>
    8000220c:	0184b403          	ld	s0,24(s1)
	if (z_is_thread_prevented_from_running(_current)) {
    80002210:	0104b783          	ld	a5,16(s1)
	if (preempt_ok != 0) {
    80002214:	02091c63          	bnez	s2,8000224c <update_cache+0x74>
	if (z_is_thread_prevented_from_running(_current)) {
    80002218:	0197c703          	lbu	a4,25(a5)
    8000221c:	01f77713          	andi	a4,a4,31
    80002220:	02071663          	bnez	a4,8000224c <update_cache+0x74>
	if (is_preempt(_current) || is_metairq(thread)) {
    80002224:	01a7d683          	lhu	a3,26(a5)
    80002228:	07f00713          	li	a4,127
    8000222c:	02d77063          	bgeu	a4,a3,8000224c <update_cache+0x74>
		_kernel.ready_q.cache = _current;
    80002230:	02f4b423          	sd	a5,40(s1)
}
    80002234:	01813083          	ld	ra,24(sp)
    80002238:	01013403          	ld	s0,16(sp)
    8000223c:	00813483          	ld	s1,8(sp)
    80002240:	00013903          	ld	s2,0(sp)
    80002244:	02010113          	addi	sp,sp,32
    80002248:	00008067          	ret
		if (thread != _current) {
    8000224c:	00f40463          	beq	s0,a5,80002254 <update_cache+0x7c>
			z_reset_time_slice();
    80002250:	e25ff0ef          	jal	ra,80002074 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
    80002254:	0284b423          	sd	s0,40(s1)
}
    80002258:	fddff06f          	j	80002234 <update_cache+0x5c>

000000008000225c <move_thread_to_end_of_prio_q>:
{
    8000225c:	ff010113          	addi	sp,sp,-16
    80002260:	00813023          	sd	s0,0(sp)
    80002264:	00113423          	sd	ra,8(sp)
	return (thread->base.thread_state & state) != 0U;
    80002268:	01954783          	lbu	a5,25(a0)
    8000226c:	00050413          	mv	s0,a0
	if (z_is_thread_queued(thread)) {
    80002270:	0187971b          	slliw	a4,a5,0x18
    80002274:	4187571b          	sraiw	a4,a4,0x18
    80002278:	00075863          	bgez	a4,80002288 <move_thread_to_end_of_prio_q+0x2c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    8000227c:	07f7f793          	andi	a5,a5,127
    80002280:	00f50ca3          	sb	a5,25(a0)
	sys_dlist_remove(&thread->base.qnode_dlist);
    80002284:	d81ff0ef          	jal	ra,80002004 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
    80002288:	01944783          	lbu	a5,25(s0)
	return list->head == list;
    8000228c:	00001717          	auipc	a4,0x1
    80002290:	05470713          	addi	a4,a4,84 # 800032e0 <_kernel>
	return sys_dlist_is_empty(list) ? NULL : list->head;
    80002294:	00001597          	auipc	a1,0x1
    80002298:	07c58593          	addi	a1,a1,124 # 80003310 <_kernel+0x30>
    8000229c:	f807e793          	ori	a5,a5,-128
    800022a0:	00f40ca3          	sb	a5,25(s0)
	return list->head == list;
    800022a4:	03073783          	ld	a5,48(a4)
	return (node == list->tail) ? NULL : node->next;
    800022a8:	03873603          	ld	a2,56(a4)
	return sys_dlist_is_empty(list) ? NULL : list->head;
    800022ac:	04b78c63          	beq	a5,a1,80002304 <move_thread_to_end_of_prio_q+0xa8>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    800022b0:	04078a63          	beqz	a5,80002304 <move_thread_to_end_of_prio_q+0xa8>
	int32_t b1 = thread_1->base.prio;
    800022b4:	01a40503          	lb	a0,26(s0)
	int32_t b2 = thread_2->base.prio;
    800022b8:	01a78803          	lb	a6,26(a5)
	if (b1 != b2) {
    800022bc:	03050e63          	beq	a0,a6,800022f8 <move_thread_to_end_of_prio_q+0x9c>
		if (z_sched_prio_cmp(thread, t) > 0) {
    800022c0:	40a806bb          	subw	a3,a6,a0
    800022c4:	02d05a63          	blez	a3,800022f8 <move_thread_to_end_of_prio_q+0x9c>
	sys_dnode_t *const prev = successor->prev;
    800022c8:	0087b683          	ld	a3,8(a5)
	node->next = successor;
    800022cc:	00f43023          	sd	a5,0(s0)
	node->prev = prev;
    800022d0:	00d43423          	sd	a3,8(s0)
	prev->next = node;
    800022d4:	0086b023          	sd	s0,0(a3)
	successor->prev = node;
    800022d8:	0087b423          	sd	s0,8(a5)
	update_cache(thread == _current);
    800022dc:	01073503          	ld	a0,16(a4)
}
    800022e0:	00813083          	ld	ra,8(sp)
	update_cache(thread == _current);
    800022e4:	40850533          	sub	a0,a0,s0
}
    800022e8:	00013403          	ld	s0,0(sp)
	update_cache(thread == _current);
    800022ec:	00153513          	seqz	a0,a0
}
    800022f0:	01010113          	addi	sp,sp,16
	update_cache(thread == _current);
    800022f4:	ee5ff06f          	j	800021d8 <update_cache>
	return (node == list->tail) ? NULL : node->next;
    800022f8:	00c78663          	beq	a5,a2,80002304 <move_thread_to_end_of_prio_q+0xa8>
    800022fc:	0007b783          	ld	a5,0(a5)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    80002300:	fa079ce3          	bnez	a5,800022b8 <move_thread_to_end_of_prio_q+0x5c>
	node->next = list;
    80002304:	00b43023          	sd	a1,0(s0)
	node->prev = tail;
    80002308:	00c43423          	sd	a2,8(s0)
	tail->next = node;
    8000230c:	00863023          	sd	s0,0(a2)
	list->tail = node;
    80002310:	02873c23          	sd	s0,56(a4)
}
    80002314:	fc9ff06f          	j	800022dc <move_thread_to_end_of_prio_q+0x80>

0000000080002318 <z_time_slice>:
{
    80002318:	ff010113          	addi	sp,sp,-16
    8000231c:	00813023          	sd	s0,0(sp)
    80002320:	00113423          	sd	ra,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    80002324:	00800413          	li	s0,8
    80002328:	30043473          	csrrc	s0,mstatus,s0
	if (slice_time && sliceable(_current)) {
    8000232c:	00001797          	auipc	a5,0x1
    80002330:	f407a783          	lw	a5,-192(a5) # 8000326c <slice_time>
	key = (mstatus & MSTATUS_IEN);
    80002334:	00847413          	andi	s0,s0,8
    80002338:	06078c63          	beqz	a5,800023b0 <z_time_slice+0x98>
    8000233c:	00001697          	auipc	a3,0x1
    80002340:	fa468693          	addi	a3,a3,-92 # 800032e0 <_kernel>
    80002344:	00050713          	mv	a4,a0
    80002348:	0106b503          	ld	a0,16(a3)
		&& !z_is_idle_thread_object(thread);
    8000234c:	07f00793          	li	a5,127
    80002350:	01a55603          	lhu	a2,26(a0)
    80002354:	04c7ee63          	bltu	a5,a2,800023b0 <z_time_slice+0x98>
		&& !z_is_thread_prevented_from_running(thread)
    80002358:	01954783          	lbu	a5,25(a0)
    8000235c:	01f7f793          	andi	a5,a5,31
    80002360:	04079863          	bnez	a5,800023b0 <z_time_slice+0x98>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
    80002364:	01a50603          	lb	a2,26(a0)
    80002368:	00001797          	auipc	a5,0x1
    8000236c:	f007a783          	lw	a5,-256(a5) # 80003268 <slice_max_prio>
    80002370:	04f64063          	blt	a2,a5,800023b0 <z_time_slice+0x98>
		&& !z_is_idle_thread_object(thread);
    80002374:	00001797          	auipc	a5,0x1
    80002378:	fac78793          	addi	a5,a5,-84 # 80003320 <z_idle_threads>
    8000237c:	02f50a63          	beq	a0,a5,800023b0 <z_time_slice+0x98>
		if (ticks >= _current_cpu->slice_ticks) {
    80002380:	0206a783          	lw	a5,32(a3)
    80002384:	02f74063          	blt	a4,a5,800023a4 <z_time_slice+0x8c>
			move_thread_to_end_of_prio_q(_current);
    80002388:	ed5ff0ef          	jal	ra,8000225c <move_thread_to_end_of_prio_q>
			z_reset_time_slice();
    8000238c:	ce9ff0ef          	jal	ra,80002074 <z_reset_time_slice>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    80002390:	30042473          	csrrs	s0,mstatus,s0
}
    80002394:	00813083          	ld	ra,8(sp)
    80002398:	00013403          	ld	s0,0(sp)
    8000239c:	01010113          	addi	sp,sp,16
    800023a0:	00008067          	ret
			_current_cpu->slice_ticks -= ticks;
    800023a4:	40e787bb          	subw	a5,a5,a4
    800023a8:	02f6a023          	sw	a5,32(a3)
    800023ac:	fe5ff06f          	j	80002390 <z_time_slice+0x78>
		_current_cpu->slice_ticks = 0;
    800023b0:	00001797          	auipc	a5,0x1
    800023b4:	f407a823          	sw	zero,-176(a5) # 80003300 <_kernel+0x20>
    800023b8:	fd9ff06f          	j	80002390 <z_time_slice+0x78>

00000000800023bc <ready_thread>:
    800023bc:	01954783          	lbu	a5,25(a0)
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
    800023c0:	0187971b          	slliw	a4,a5,0x18
    800023c4:	4187571b          	sraiw	a4,a4,0x18
    800023c8:	08074663          	bltz	a4,80002454 <ready_thread+0x98>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    800023cc:	01f7f713          	andi	a4,a5,31
    800023d0:	08071263          	bnez	a4,80002454 <ready_thread+0x98>
    800023d4:	02853703          	ld	a4,40(a0)
    800023d8:	06071e63          	bnez	a4,80002454 <ready_thread+0x98>
	thread->base.thread_state |= _THREAD_QUEUED;
    800023dc:	f807e793          	ori	a5,a5,-128
    800023e0:	00f50ca3          	sb	a5,25(a0)
	return list->head == list;
    800023e4:	00001697          	auipc	a3,0x1
    800023e8:	efc68693          	addi	a3,a3,-260 # 800032e0 <_kernel>
    800023ec:	0306b783          	ld	a5,48(a3)
	return sys_dlist_is_empty(list) ? NULL : list->head;
    800023f0:	00001597          	auipc	a1,0x1
    800023f4:	f2058593          	addi	a1,a1,-224 # 80003310 <_kernel+0x30>
	return (node == list->tail) ? NULL : node->next;
    800023f8:	0386b603          	ld	a2,56(a3)
	return sys_dlist_is_empty(list) ? NULL : list->head;
    800023fc:	04b78263          	beq	a5,a1,80002440 <ready_thread+0x84>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    80002400:	04078063          	beqz	a5,80002440 <ready_thread+0x84>
	int32_t b1 = thread_1->base.prio;
    80002404:	01a50803          	lb	a6,26(a0)
	int32_t b2 = thread_2->base.prio;
    80002408:	01a78883          	lb	a7,26(a5)
	if (b1 != b2) {
    8000240c:	03180463          	beq	a6,a7,80002434 <ready_thread+0x78>
		if (z_sched_prio_cmp(thread, t) > 0) {
    80002410:	4108873b          	subw	a4,a7,a6
    80002414:	02e05063          	blez	a4,80002434 <ready_thread+0x78>
	sys_dnode_t *const prev = successor->prev;
    80002418:	0087b703          	ld	a4,8(a5)
	node->next = successor;
    8000241c:	00f53023          	sd	a5,0(a0)
	node->prev = prev;
    80002420:	00e53423          	sd	a4,8(a0)
	prev->next = node;
    80002424:	00a73023          	sd	a0,0(a4)
	successor->prev = node;
    80002428:	00a7b423          	sd	a0,8(a5)
		update_cache(0);
    8000242c:	00000513          	li	a0,0
    80002430:	da9ff06f          	j	800021d8 <update_cache>
	return (node == list->tail) ? NULL : node->next;
    80002434:	00c78663          	beq	a5,a2,80002440 <ready_thread+0x84>
    80002438:	0007b783          	ld	a5,0(a5)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    8000243c:	fc0796e3          	bnez	a5,80002408 <ready_thread+0x4c>
	node->next = list;
    80002440:	00b53023          	sd	a1,0(a0)
	node->prev = tail;
    80002444:	00c53423          	sd	a2,8(a0)
	tail->next = node;
    80002448:	00a63023          	sd	a0,0(a2)
	list->tail = node;
    8000244c:	02a6bc23          	sd	a0,56(a3)
}
    80002450:	fddff06f          	j	8000242c <ready_thread+0x70>
}
    80002454:	00008067          	ret

0000000080002458 <z_ready_thread>:
{
    80002458:	ff010113          	addi	sp,sp,-16
    8000245c:	00813023          	sd	s0,0(sp)
    80002460:	00113423          	sd	ra,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    80002464:	00800413          	li	s0,8
    80002468:	30043473          	csrrc	s0,mstatus,s0
			ready_thread(thread);
    8000246c:	f51ff0ef          	jal	ra,800023bc <ready_thread>
			  : "r" (key & MSTATUS_IEN)
    80002470:	00847413          	andi	s0,s0,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
    80002474:	30042473          	csrrs	s0,mstatus,s0
}
    80002478:	00813083          	ld	ra,8(sp)
    8000247c:	00013403          	ld	s0,0(sp)
    80002480:	01010113          	addi	sp,sp,16
    80002484:	00008067          	ret

0000000080002488 <z_sched_start>:
{
    80002488:	ff010113          	addi	sp,sp,-16
    8000248c:	00813023          	sd	s0,0(sp)
    80002490:	00113423          	sd	ra,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    80002494:	00800413          	li	s0,8
    80002498:	30043473          	csrrc	s0,mstatus,s0
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
    8000249c:	01954703          	lbu	a4,25(a0)
	key = (mstatus & MSTATUS_IEN);
    800024a0:	00847413          	andi	s0,s0,8
	if (z_has_thread_started(thread)) {
    800024a4:	00477693          	andi	a3,a4,4
    800024a8:	00069c63          	bnez	a3,800024c0 <z_sched_start+0x38>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    800024ac:	30042473          	csrrs	s0,mstatus,s0
}
    800024b0:	00813083          	ld	ra,8(sp)
    800024b4:	00013403          	ld	s0,0(sp)
    800024b8:	01010113          	addi	sp,sp,16
    800024bc:	00008067          	ret
	thread->base.thread_state &= ~_THREAD_PRESTART;
    800024c0:	ffb77713          	andi	a4,a4,-5
    800024c4:	00e50ca3          	sb	a4,25(a0)
	ready_thread(thread);
    800024c8:	ef5ff0ef          	jal	ra,800023bc <ready_thread>
	z_reschedule(&sched_spinlock, key);
    800024cc:	00040593          	mv	a1,s0
}
    800024d0:	00013403          	ld	s0,0(sp)
    800024d4:	00813083          	ld	ra,8(sp)
	z_reschedule(&sched_spinlock, key);
    800024d8:	00001517          	auipc	a0,0x1
    800024dc:	03850513          	addi	a0,a0,56 # 80003510 <z_main_stack>
}
    800024e0:	01010113          	addi	sp,sp,16
	z_reschedule(&sched_spinlock, key);
    800024e4:	c55ff06f          	j	80002138 <z_reschedule>

00000000800024e8 <z_thread_timeout>:
{
    800024e8:	fd010113          	addi	sp,sp,-48
    800024ec:	00913c23          	sd	s1,24(sp)
    800024f0:	02113423          	sd	ra,40(sp)
    800024f4:	02813023          	sd	s0,32(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    800024f8:	00800493          	li	s1,8
    800024fc:	3004b4f3          	csrrc	s1,mstatus,s1
		if (!killed) {
    80002500:	ff154783          	lbu	a5,-15(a0)
	key = (mstatus & MSTATUS_IEN);
    80002504:	0084f493          	andi	s1,s1,8
    80002508:	0287f793          	andi	a5,a5,40
    8000250c:	02079863          	bnez	a5,8000253c <z_thread_timeout+0x54>
    80002510:	00050413          	mv	s0,a0
			if (thread->base.pended_on != NULL) {
    80002514:	fe843783          	ld	a5,-24(s0)
	struct k_thread *thread = CONTAINER_OF(timeout,
    80002518:	fd850513          	addi	a0,a0,-40
			if (thread->base.pended_on != NULL) {
    8000251c:	00078863          	beqz	a5,8000252c <z_thread_timeout+0x44>
				unpend_thread_no_timeout(thread);
    80002520:	00a13423          	sd	a0,8(sp)
    80002524:	afdff0ef          	jal	ra,80002020 <unpend_thread_no_timeout>
    80002528:	00813503          	ld	a0,8(sp)
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
    8000252c:	ff144783          	lbu	a5,-15(s0)
    80002530:	feb7f793          	andi	a5,a5,-21
    80002534:	fef408a3          	sb	a5,-15(s0)
			ready_thread(thread);
    80002538:	e85ff0ef          	jal	ra,800023bc <ready_thread>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    8000253c:	3004a4f3          	csrrs	s1,mstatus,s1
}
    80002540:	02813083          	ld	ra,40(sp)
    80002544:	02013403          	ld	s0,32(sp)
    80002548:	01813483          	ld	s1,24(sp)
    8000254c:	03010113          	addi	sp,sp,48
    80002550:	00008067          	ret

0000000080002554 <k_sched_unlock>:
{
    80002554:	ff010113          	addi	sp,sp,-16
    80002558:	00813023          	sd	s0,0(sp)
    8000255c:	00113423          	sd	ra,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    80002560:	00800413          	li	s0,8
    80002564:	30043473          	csrrc	s0,mstatus,s0
		++_current->base.sched_locked;
    80002568:	00001717          	auipc	a4,0x1
    8000256c:	d8873703          	ld	a4,-632(a4) # 800032f0 <_kernel+0x10>
    80002570:	01b74783          	lbu	a5,27(a4)
		update_cache(0);
    80002574:	00000513          	li	a0,0
			  : "r" (key & MSTATUS_IEN)
    80002578:	00847413          	andi	s0,s0,8
		++_current->base.sched_locked;
    8000257c:	0017879b          	addiw	a5,a5,1
    80002580:	00f70da3          	sb	a5,27(a4)
		update_cache(0);
    80002584:	c55ff0ef          	jal	ra,800021d8 <update_cache>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    80002588:	30042473          	csrrs	s0,mstatus,s0
}
    8000258c:	00013403          	ld	s0,0(sp)
    80002590:	00813083          	ld	ra,8(sp)
    80002594:	01010113          	addi	sp,sp,16
	z_reschedule_unlocked();
    80002598:	bf5ff06f          	j	8000218c <z_reschedule_unlocked>

000000008000259c <z_sched_init>:
	list->head = (sys_dnode_t *)list;
    8000259c:	00001797          	auipc	a5,0x1
    800025a0:	d4478793          	addi	a5,a5,-700 # 800032e0 <_kernel>
    800025a4:	00001717          	auipc	a4,0x1
    800025a8:	d6c70713          	addi	a4,a4,-660 # 80003310 <_kernel+0x30>
    800025ac:	02e7b823          	sd	a4,48(a5)
	list->tail = (sys_dnode_t *)list;
    800025b0:	02e7bc23          	sd	a4,56(a5)
#else
	init_ready_q(&_kernel.ready_q);
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
    800025b4:	00000593          	li	a1,0
    800025b8:	00000513          	li	a0,0
    800025bc:	b11ff06f          	j	800020cc <k_sched_time_slice_set>

00000000800025c0 <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
    800025c0:	00001517          	auipc	a0,0x1
    800025c4:	d3053503          	ld	a0,-720(a0) # 800032f0 <_kernel+0x10>
    800025c8:	00008067          	ret

00000000800025cc <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
    800025cc:	fd010113          	addi	sp,sp,-48
    800025d0:	00913c23          	sd	s1,24(sp)
    800025d4:	02113423          	sd	ra,40(sp)
    800025d8:	02813023          	sd	s0,32(sp)
    800025dc:	01213823          	sd	s2,16(sp)
    800025e0:	01313423          	sd	s3,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    800025e4:	00800493          	li	s1,8
    800025e8:	3004b4f3          	csrrc	s1,mstatus,s1
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
    800025ec:	01954783          	lbu	a5,25(a0)
	key = (mstatus & MSTATUS_IEN);
    800025f0:	0084f493          	andi	s1,s1,8
    800025f4:	0087f713          	andi	a4,a5,8
    800025f8:	02070263          	beqz	a4,8000261c <z_thread_abort+0x50>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    800025fc:	3004a4f3          	csrrs	s1,mstatus,s1
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
    80002600:	02813083          	ld	ra,40(sp)
    80002604:	02013403          	ld	s0,32(sp)
    80002608:	01813483          	ld	s1,24(sp)
    8000260c:	01013903          	ld	s2,16(sp)
    80002610:	00813983          	ld	s3,8(sp)
    80002614:	03010113          	addi	sp,sp,48
    80002618:	00008067          	ret
		thread->base.thread_state &= ~_THREAD_ABORTING;
    8000261c:	fdf7f713          	andi	a4,a5,-33
    80002620:	00876713          	ori	a4,a4,8
		if (z_is_thread_queued(thread)) {
    80002624:	0187169b          	slliw	a3,a4,0x18
    80002628:	4186d69b          	sraiw	a3,a3,0x18
    8000262c:	00050413          	mv	s0,a0
    80002630:	0406ce63          	bltz	a3,8000268c <z_thread_abort+0xc0>
		thread->base.thread_state &= ~_THREAD_ABORTING;
    80002634:	00e50ca3          	sb	a4,25(a0)
		if (thread->base.pended_on != NULL) {
    80002638:	01043783          	ld	a5,16(s0)
    8000263c:	00078663          	beqz	a5,80002648 <z_thread_abort+0x7c>
			unpend_thread_no_timeout(thread);
    80002640:	00040513          	mv	a0,s0
    80002644:	9ddff0ef          	jal	ra,80002020 <unpend_thread_no_timeout>
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
    80002648:	02840513          	addi	a0,s0,40
    8000264c:	318000ef          	jal	ra,80002964 <z_abort_timeout>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
    80002650:	0b840993          	addi	s3,s0,184
	return list->head == list;
    80002654:	0b843903          	ld	s2,184(s0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
    80002658:	01390463          	beq	s2,s3,80002660 <z_thread_abort+0x94>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
    8000265c:	04091263          	bnez	s2,800026a0 <z_thread_abort+0xd4>
		update_cache(1);
    80002660:	00100513          	li	a0,1
    80002664:	b75ff0ef          	jal	ra,800021d8 <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
    80002668:	00001797          	auipc	a5,0x1
    8000266c:	c7878793          	addi	a5,a5,-904 # 800032e0 <_kernel>
    80002670:	0107b703          	ld	a4,16(a5)
    80002674:	f88714e3          	bne	a4,s0,800025fc <z_thread_abort+0x30>
    80002678:	0007a783          	lw	a5,0(a5)
    8000267c:	f80790e3          	bnez	a5,800025fc <z_thread_abort+0x30>
    80002680:	00048513          	mv	a0,s1
    80002684:	9d1ff0ef          	jal	ra,80002054 <z_swap_irqlock>
    80002688:	f75ff06f          	j	800025fc <z_thread_abort+0x30>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    8000268c:	05f7f793          	andi	a5,a5,95
    80002690:	0087e793          	ori	a5,a5,8
    80002694:	00f50ca3          	sb	a5,25(a0)
	sys_dlist_remove(&thread->base.qnode_dlist);
    80002698:	96dff0ef          	jal	ra,80002004 <sys_dlist_remove>
}
    8000269c:	f9dff06f          	j	80002638 <z_thread_abort+0x6c>
		unpend_thread_no_timeout(thread);
    800026a0:	00090513          	mv	a0,s2
    800026a4:	97dff0ef          	jal	ra,80002020 <unpend_thread_no_timeout>
    800026a8:	02890513          	addi	a0,s2,40
    800026ac:	2b8000ef          	jal	ra,80002964 <z_abort_timeout>
		ready_thread(thread);
    800026b0:	00090513          	mv	a0,s2
	thread->arch.swap_return_value = value;
    800026b4:	0e092823          	sw	zero,240(s2)
    800026b8:	d05ff0ef          	jal	ra,800023bc <ready_thread>
    800026bc:	f99ff06f          	j	80002654 <z_thread_abort+0x88>

00000000800026c0 <z_impl_k_thread_abort>:
#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(struct k_thread *thread)
{
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_thread, abort, thread);

	z_thread_abort(thread);
    800026c0:	f0dff06f          	j	800025cc <z_thread_abort>

00000000800026c4 <first>:
#endif /* CONFIG_USERSPACE */
#endif /* CONFIG_TIMER_READS_ITS_FREQUENCY_AT_RUNTIME */

static struct _timeout *first(void)
{
  if (timeout_list_init_done == 0){
    800026c4:	00001717          	auipc	a4,0x1
    800026c8:	bb170713          	addi	a4,a4,-1103 # 80003275 <timeout_list_init_done>
    800026cc:	00074683          	lbu	a3,0(a4)
    800026d0:	00003797          	auipc	a5,0x3
    800026d4:	84078793          	addi	a5,a5,-1984 # 80004f10 <timeout_list>
    800026d8:	00069a63          	bnez	a3,800026ec <first+0x28>
    sys_dlist_init(&timeout_list);
    timeout_list_init_done = 1;
    800026dc:	00100693          	li	a3,1
	list->head = (sys_dnode_t *)list;
    800026e0:	00f7b023          	sd	a5,0(a5)
	list->tail = (sys_dnode_t *)list;
    800026e4:	00f7b423          	sd	a5,8(a5)
    800026e8:	00d70023          	sb	a3,0(a4)
	return list->head == list;
    800026ec:	0007b503          	ld	a0,0(a5)
	return sys_dlist_is_empty(list) ? NULL : list->head;
    800026f0:	00f51463          	bne	a0,a5,800026f8 <first+0x34>
    800026f4:	00000513          	li	a0,0
  } 
  
	sys_dnode_t *t = sys_dlist_peek_head(&timeout_list);

	return t == NULL ? NULL : CONTAINER_OF(t, struct _timeout, node);
}
    800026f8:	00008067          	ret

00000000800026fc <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
    800026fc:	00001797          	auipc	a5,0x1
    80002700:	b747a783          	lw	a5,-1164(a5) # 80003270 <announce_remaining>
    80002704:	00079463          	bnez	a5,8000270c <elapsed+0x10>
    80002708:	c74ff06f          	j	80001b7c <sys_clock_elapsed>
}
    8000270c:	00000513          	li	a0,0
    80002710:	00008067          	ret

0000000080002714 <next_timeout>:

static int32_t next_timeout(void)
{
    80002714:	ff010113          	addi	sp,sp,-16
    80002718:	00813023          	sd	s0,0(sp)
    8000271c:	00113423          	sd	ra,8(sp)
	struct _timeout *to = first();
    80002720:	fa5ff0ef          	jal	ra,800026c4 <first>
    80002724:	00050413          	mv	s0,a0
	int32_t ticks_elapsed = elapsed();
    80002728:	fd5ff0ef          	jal	ra,800026fc <elapsed>
	int32_t ret = to == NULL ? MAX_WAIT
    8000272c:	04040c63          	beqz	s0,80002784 <next_timeout+0x70>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    80002730:	01843783          	ld	a5,24(s0)
    80002734:	40a787b3          	sub	a5,a5,a0
	int32_t ret = to == NULL ? MAX_WAIT
    80002738:	00000513          	li	a0,0
    8000273c:	00f05e63          	blez	a5,80002758 <next_timeout+0x44>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    80002740:	00078513          	mv	a0,a5
    80002744:	800007b7          	lui	a5,0x80000
    80002748:	fff7c793          	not	a5,a5
    8000274c:	00a7d463          	bge	a5,a0,80002754 <next_timeout+0x40>
    80002750:	00078513          	mv	a0,a5
	int32_t ret = to == NULL ? MAX_WAIT
    80002754:	0005051b          	sext.w	a0,a0

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
    80002758:	00001797          	auipc	a5,0x1
    8000275c:	ba87a783          	lw	a5,-1112(a5) # 80003300 <_kernel+0x20>
    80002760:	00078a63          	beqz	a5,80002774 <next_timeout+0x60>
    80002764:	00078713          	mv	a4,a5
    80002768:	00f55463          	bge	a0,a5,80002770 <next_timeout+0x5c>
    8000276c:	00050713          	mv	a4,a0
    80002770:	0007051b          	sext.w	a0,a4
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
    80002774:	00813083          	ld	ra,8(sp)
    80002778:	00013403          	ld	s0,0(sp)
    8000277c:	01010113          	addi	sp,sp,16
    80002780:	00008067          	ret
	int32_t ret = to == NULL ? MAX_WAIT
    80002784:	80000537          	lui	a0,0x80000
    80002788:	fff54513          	not	a0,a0
    8000278c:	fcdff06f          	j	80002758 <next_timeout+0x44>

0000000080002790 <next>:
  if (timeout_list_init_done == 0){
    80002790:	00001717          	auipc	a4,0x1
    80002794:	ae570713          	addi	a4,a4,-1307 # 80003275 <timeout_list_init_done>
    80002798:	00074783          	lbu	a5,0(a4)
    8000279c:	00079e63          	bnez	a5,800027b8 <next+0x28>
	list->head = (sys_dnode_t *)list;
    800027a0:	00002797          	auipc	a5,0x2
    800027a4:	77078793          	addi	a5,a5,1904 # 80004f10 <timeout_list>
    800027a8:	00f7b023          	sd	a5,0(a5)
	list->tail = (sys_dnode_t *)list;
    800027ac:	00f7b423          	sd	a5,8(a5)
    timeout_list_init_done = 1;
    800027b0:	00100793          	li	a5,1
    800027b4:	00f70023          	sb	a5,0(a4)
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    800027b8:	00050e63          	beqz	a0,800027d4 <next+0x44>
	return (node == list->tail) ? NULL : node->next;
    800027bc:	00002797          	auipc	a5,0x2
    800027c0:	75c7b783          	ld	a5,1884(a5) # 80004f18 <timeout_list+0x8>
    800027c4:	00f50663          	beq	a0,a5,800027d0 <next+0x40>
    800027c8:	00053503          	ld	a0,0(a0) # ffffffff80000000 <__data_region_end+0xfffffffeffffb0cc>
    800027cc:	00008067          	ret
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    800027d0:	00000513          	li	a0,0
}
    800027d4:	00008067          	ret

00000000800027d8 <remove_timeout>:
{
    800027d8:	ff010113          	addi	sp,sp,-16
    800027dc:	00813023          	sd	s0,0(sp)
    800027e0:	00113423          	sd	ra,8(sp)
    800027e4:	00050413          	mv	s0,a0
	if (next(t) != NULL) {
    800027e8:	fa9ff0ef          	jal	ra,80002790 <next>
    800027ec:	00050e63          	beqz	a0,80002808 <remove_timeout+0x30>
		next(t)->dticks += t->dticks;
    800027f0:	00040513          	mv	a0,s0
    800027f4:	f9dff0ef          	jal	ra,80002790 <next>
    800027f8:	01853783          	ld	a5,24(a0)
    800027fc:	01843703          	ld	a4,24(s0)
    80002800:	00e787b3          	add	a5,a5,a4
    80002804:	00f53c23          	sd	a5,24(a0)
	sys_dnode_t *const prev = node->prev;
    80002808:	00843703          	ld	a4,8(s0)
	sys_dnode_t *const next = node->next;
    8000280c:	00043783          	ld	a5,0(s0)
}
    80002810:	00813083          	ld	ra,8(sp)
	prev->next = next;
    80002814:	00f73023          	sd	a5,0(a4)
	next->prev = prev;
    80002818:	00e7b423          	sd	a4,8(a5)
	node->next = NULL;
    8000281c:	00043023          	sd	zero,0(s0)
	node->prev = NULL;
    80002820:	00043423          	sd	zero,8(s0)
    80002824:	00013403          	ld	s0,0(sp)
    80002828:	01010113          	addi	sp,sp,16
    8000282c:	00008067          	ret

0000000080002830 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
    80002830:	fe010113          	addi	sp,sp,-32
    80002834:	00813823          	sd	s0,16(sp)
    80002838:	00913423          	sd	s1,8(sp)
    8000283c:	00113c23          	sd	ra,24(sp)
    80002840:	01213023          	sd	s2,0(sp)
  
  if (timeout_list_init_done == 0){
    80002844:	00001717          	auipc	a4,0x1
    80002848:	a3170713          	addi	a4,a4,-1487 # 80003275 <timeout_list_init_done>
    8000284c:	00074783          	lbu	a5,0(a4)
{
    80002850:	00050413          	mv	s0,a0
    80002854:	00060493          	mv	s1,a2
  if (timeout_list_init_done == 0){
    80002858:	00079e63          	bnez	a5,80002874 <z_add_timeout+0x44>
	list->head = (sys_dnode_t *)list;
    8000285c:	00002797          	auipc	a5,0x2
    80002860:	6b478793          	addi	a5,a5,1716 # 80004f10 <timeout_list>
    80002864:	00f7b023          	sd	a5,0(a5)
	list->tail = (sys_dnode_t *)list;
    80002868:	00f7b423          	sd	a5,8(a5)
    sys_dlist_init(&timeout_list);
    timeout_list_init_done = 1;
    8000286c:	00100793          	li	a5,1
    80002870:	00f70023          	sb	a5,0(a4)
  } 

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    80002874:	fff00793          	li	a5,-1
    80002878:	0cf48263          	beq	s1,a5,8000293c <z_add_timeout+0x10c>
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
    8000287c:	00b43823          	sd	a1,16(s0)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    80002880:	00800913          	li	s2,8
    80002884:	30093973          	csrrc	s2,mstatus,s2

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
		    Z_TICK_ABS(timeout.ticks) >= 0) {
    80002888:	ffe00793          	li	a5,-2
    8000288c:	40978733          	sub	a4,a5,s1
	key = (mstatus & MSTATUS_IEN);
    80002890:	00897913          	andi	s2,s2,8
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
    80002894:	04074463          	bltz	a4,800028dc <z_add_timeout+0xac>
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
    80002898:	00001617          	auipc	a2,0x1
    8000289c:	9c063603          	ld	a2,-1600(a2) # 80003258 <curr_tick>
    800028a0:	40c787b3          	sub	a5,a5,a2
    800028a4:	409784b3          	sub	s1,a5,s1

			to->dticks = MAX(1, ticks);
    800028a8:	00904463          	bgtz	s1,800028b0 <z_add_timeout+0x80>
    800028ac:	00100493          	li	s1,1
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
    800028b0:	00943c23          	sd	s1,24(s0)
		}

		for (t = first(); t != NULL; t = next(t)) {
    800028b4:	e11ff0ef          	jal	ra,800026c4 <first>
    800028b8:	02051a63          	bnez	a0,800028ec <z_add_timeout+0xbc>
	sys_dnode_t *const tail = list->tail;
    800028bc:	00002797          	auipc	a5,0x2
    800028c0:	65478793          	addi	a5,a5,1620 # 80004f10 <timeout_list>
    800028c4:	0087b703          	ld	a4,8(a5)
	node->next = list;
    800028c8:	00f43023          	sd	a5,0(s0)
	node->prev = tail;
    800028cc:	00e43423          	sd	a4,8(s0)
	tail->next = node;
    800028d0:	00873023          	sd	s0,0(a4)
	list->tail = node;
    800028d4:	0087b423          	sd	s0,8(a5)
}
    800028d8:	03c0006f          	j	80002914 <z_add_timeout+0xe4>
			to->dticks = timeout.ticks + 1 + elapsed();
    800028dc:	e21ff0ef          	jal	ra,800026fc <elapsed>
    800028e0:	00148493          	addi	s1,s1,1
    800028e4:	00a484b3          	add	s1,s1,a0
    800028e8:	fc9ff06f          	j	800028b0 <z_add_timeout+0x80>
			if (t->dticks > to->dticks) {
    800028ec:	01853703          	ld	a4,24(a0)
    800028f0:	01843783          	ld	a5,24(s0)
    800028f4:	06e7d063          	bge	a5,a4,80002954 <z_add_timeout+0x124>
				t->dticks -= to->dticks;
    800028f8:	40f707b3          	sub	a5,a4,a5
    800028fc:	00f53c23          	sd	a5,24(a0)
	sys_dnode_t *const prev = successor->prev;
    80002900:	00853783          	ld	a5,8(a0)
	node->next = successor;
    80002904:	00a43023          	sd	a0,0(s0)
	node->prev = prev;
    80002908:	00f43423          	sd	a5,8(s0)
	prev->next = node;
    8000290c:	0087b023          	sd	s0,0(a5)
	successor->prev = node;
    80002910:	00853423          	sd	s0,8(a0)

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
    80002914:	db1ff0ef          	jal	ra,800026c4 <first>
    80002918:	02a41063          	bne	s0,a0,80002938 <z_add_timeout+0x108>
			 * last announcement, and slice_ticks is based
			 * on that. It means that the time remaining for
			 * the next announcement can be less than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
    8000291c:	df9ff0ef          	jal	ra,80002714 <next_timeout>

			if (next_time == 0 ||
    80002920:	00050863          	beqz	a0,80002930 <z_add_timeout+0x100>
    80002924:	00001797          	auipc	a5,0x1
    80002928:	9dc7a783          	lw	a5,-1572(a5) # 80003300 <_kernel+0x20>
    8000292c:	00a78663          	beq	a5,a0,80002938 <z_add_timeout+0x108>
			    _current_cpu->slice_ticks != next_time) {
				sys_clock_set_timeout(next_time, false);
    80002930:	00000593          	li	a1,0
    80002934:	97cff0ef          	jal	ra,80001ab0 <sys_clock_set_timeout>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    80002938:	30092973          	csrrs	s2,mstatus,s2
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
    8000293c:	01813083          	ld	ra,24(sp)
    80002940:	01013403          	ld	s0,16(sp)
    80002944:	00813483          	ld	s1,8(sp)
    80002948:	00013903          	ld	s2,0(sp)
    8000294c:	02010113          	addi	sp,sp,32
    80002950:	00008067          	ret
			to->dticks -= t->dticks;
    80002954:	40e787b3          	sub	a5,a5,a4
    80002958:	00f43c23          	sd	a5,24(s0)
		for (t = first(); t != NULL; t = next(t)) {
    8000295c:	e35ff0ef          	jal	ra,80002790 <next>
    80002960:	f59ff06f          	j	800028b8 <z_add_timeout+0x88>

0000000080002964 <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
    80002964:	ff010113          	addi	sp,sp,-16
    80002968:	00813023          	sd	s0,0(sp)
    8000296c:	00113423          	sd	ra,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    80002970:	00800413          	li	s0,8
    80002974:	30043473          	csrrc	s0,mstatus,s0
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
    80002978:	00053783          	ld	a5,0(a0)
	key = (mstatus & MSTATUS_IEN);
    8000297c:	00847413          	andi	s0,s0,8
    80002980:	02078063          	beqz	a5,800029a0 <z_abort_timeout+0x3c>
			remove_timeout(to);
    80002984:	e55ff0ef          	jal	ra,800027d8 <remove_timeout>
			ret = 0;
    80002988:	00000513          	li	a0,0
	__asm__ volatile ("csrrs %0, mstatus, %1"
    8000298c:	30042473          	csrrs	s0,mstatus,s0
		}
	}

	return ret;
}
    80002990:	00813083          	ld	ra,8(sp)
    80002994:	00013403          	ld	s0,0(sp)
    80002998:	01010113          	addi	sp,sp,16
    8000299c:	00008067          	ret
	int ret = -EINVAL;
    800029a0:	fea00513          	li	a0,-22
    800029a4:	fe9ff06f          	j	8000298c <z_abort_timeout+0x28>

00000000800029a8 <z_set_timeout_expiry>:
	}
	return ret;
}

void z_set_timeout_expiry(int32_t ticks, bool is_idle)
{
    800029a8:	fd010113          	addi	sp,sp,-48
    800029ac:	02813023          	sd	s0,32(sp)
    800029b0:	00913c23          	sd	s1,24(sp)
    800029b4:	02113423          	sd	ra,40(sp)
    800029b8:	00050493          	mv	s1,a0
    800029bc:	00b13423          	sd	a1,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
    800029c0:	00800413          	li	s0,8
    800029c4:	30043473          	csrrc	s0,mstatus,s0
	LOCKED(&timeout_lock) {
		int next_to = next_timeout();
    800029c8:	d4dff0ef          	jal	ra,80002714 <next_timeout>
		 * SMP can't use this optimization though: we don't
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
    800029cc:	00100793          	li	a5,1
	key = (mstatus & MSTATUS_IEN);
    800029d0:	00847413          	andi	s0,s0,8
    800029d4:	00a7da63          	bge	a5,a0,800029e8 <z_set_timeout_expiry+0x40>
    800029d8:	00813583          	ld	a1,8(sp)
    800029dc:	00954663          	blt	a0,s1,800029e8 <z_set_timeout_expiry+0x40>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
    800029e0:	00048513          	mv	a0,s1
    800029e4:	8ccff0ef          	jal	ra,80001ab0 <sys_clock_set_timeout>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    800029e8:	30042473          	csrrs	s0,mstatus,s0
		}
	}
}
    800029ec:	02813083          	ld	ra,40(sp)
    800029f0:	02013403          	ld	s0,32(sp)
    800029f4:	01813483          	ld	s1,24(sp)
    800029f8:	03010113          	addi	sp,sp,48
    800029fc:	00008067          	ret

0000000080002a00 <sys_clock_announce>:

void sys_clock_announce(int32_t ticks)
{
    80002a00:	fc010113          	addi	sp,sp,-64
    80002a04:	02813823          	sd	s0,48(sp)
    80002a08:	02913423          	sd	s1,40(sp)
    80002a0c:	02113c23          	sd	ra,56(sp)
    80002a10:	03213023          	sd	s2,32(sp)
    80002a14:	01313c23          	sd	s3,24(sp)
    80002a18:	01413823          	sd	s4,16(sp)
    80002a1c:	01513423          	sd	s5,8(sp)
    80002a20:	01613023          	sd	s6,0(sp)
    80002a24:	00050493          	mv	s1,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
    80002a28:	00800413          	li	s0,8
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
    80002a2c:	8edff0ef          	jal	ra,80002318 <z_time_slice>
    80002a30:	30043473          	csrrc	s0,mstatus,s0
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
    80002a34:	00001a97          	auipc	s5,0x1
    80002a38:	83ca8a93          	addi	s5,s5,-1988 # 80003270 <announce_remaining>

	/* Note that we need to use the underlying arch-specific lock
	 * implementation.  The "irq_lock()" API in SMP context is
	 * actually a wrapper for a global spinlock!
	 */
	k.key = arch_irq_lock();
    80002a3c:	00847413          	andi	s0,s0,8
    80002a40:	009aa023          	sw	s1,0(s5)

	while (first() != NULL && first()->dticks <= announce_remaining) {
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
    80002a44:	00001a17          	auipc	s4,0x1
    80002a48:	814a0a13          	addi	s4,s4,-2028 # 80003258 <curr_tick>
    80002a4c:	00800b13          	li	s6,8
	while (first() != NULL && first()->dticks <= announce_remaining) {
    80002a50:	c75ff0ef          	jal	ra,800026c4 <first>
		curr_tick += dt;
    80002a54:	000a3983          	ld	s3,0(s4)
	while (first() != NULL && first()->dticks <= announce_remaining) {
    80002a58:	000aa483          	lw	s1,0(s5)
    80002a5c:	04051a63          	bnez	a0,80002ab0 <sys_clock_announce+0xb0>
		k_spin_unlock(&timeout_lock, key);
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
    80002a60:	c65ff0ef          	jal	ra,800026c4 <first>
    80002a64:	08051c63          	bnez	a0,80002afc <sys_clock_announce+0xfc>
		first()->dticks -= announce_remaining;
	}

	curr_tick += announce_remaining;
    80002a68:	013484b3          	add	s1,s1,s3
    80002a6c:	009a3023          	sd	s1,0(s4)
	announce_remaining = 0;
    80002a70:	00001797          	auipc	a5,0x1
    80002a74:	8007a023          	sw	zero,-2048(a5) # 80003270 <announce_remaining>

	sys_clock_set_timeout(next_timeout(), false);
    80002a78:	c9dff0ef          	jal	ra,80002714 <next_timeout>
    80002a7c:	00000593          	li	a1,0
    80002a80:	830ff0ef          	jal	ra,80001ab0 <sys_clock_set_timeout>
	__asm__ volatile ("csrrs %0, mstatus, %1"
    80002a84:	30042473          	csrrs	s0,mstatus,s0

	k_spin_unlock(&timeout_lock, key);
}
    80002a88:	03813083          	ld	ra,56(sp)
    80002a8c:	03013403          	ld	s0,48(sp)
    80002a90:	02813483          	ld	s1,40(sp)
    80002a94:	02013903          	ld	s2,32(sp)
    80002a98:	01813983          	ld	s3,24(sp)
    80002a9c:	01013a03          	ld	s4,16(sp)
    80002aa0:	00813a83          	ld	s5,8(sp)
    80002aa4:	00013b03          	ld	s6,0(sp)
    80002aa8:	04010113          	addi	sp,sp,64
    80002aac:	00008067          	ret
	while (first() != NULL && first()->dticks <= announce_remaining) {
    80002ab0:	c15ff0ef          	jal	ra,800026c4 <first>
    80002ab4:	01853783          	ld	a5,24(a0)
    80002ab8:	faf4c4e3          	blt	s1,a5,80002a60 <sys_clock_announce+0x60>
		struct _timeout *t = first();
    80002abc:	c09ff0ef          	jal	ra,800026c4 <first>
		int dt = t->dticks;
    80002ac0:	01852783          	lw	a5,24(a0)
		t->dticks = 0;
    80002ac4:	00053c23          	sd	zero,24(a0)
		struct _timeout *t = first();
    80002ac8:	00050913          	mv	s2,a0
		curr_tick += dt;
    80002acc:	013789b3          	add	s3,a5,s3
		announce_remaining -= dt;
    80002ad0:	40f487bb          	subw	a5,s1,a5
		curr_tick += dt;
    80002ad4:	013a3023          	sd	s3,0(s4)
		announce_remaining -= dt;
    80002ad8:	00faa023          	sw	a5,0(s5)
		remove_timeout(t);
    80002adc:	cfdff0ef          	jal	ra,800027d8 <remove_timeout>
    80002ae0:	30042473          	csrrs	s0,mstatus,s0
		t->fn(t);
    80002ae4:	01093783          	ld	a5,16(s2)
    80002ae8:	00090513          	mv	a0,s2
    80002aec:	000780e7          	jalr	a5
	__asm__ volatile ("csrrc %0, mstatus, %1"
    80002af0:	300b3473          	csrrc	s0,mstatus,s6
    80002af4:	00847413          	andi	s0,s0,8
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
    80002af8:	f59ff06f          	j	80002a50 <sys_clock_announce+0x50>
		first()->dticks -= announce_remaining;
    80002afc:	bc9ff0ef          	jal	ra,800026c4 <first>
    80002b00:	01853783          	ld	a5,24(a0)
    80002b04:	409787b3          	sub	a5,a5,s1
    80002b08:	00f53c23          	sd	a5,24(a0)
    80002b0c:	f5dff06f          	j	80002a68 <sys_clock_announce+0x68>

0000000080002b10 <boot_banner>:
#else
	printk("*** Booting Zephyr OS version %s %s ***\n",
	       KERNEL_VERSION_STRING, BOOT_DELAY_BANNER);
#endif
#endif
}
    80002b10:	00008067          	ret

0000000080002b14 <z_device_state_init>:

	while (dev < __device_end) {
		z_object_init(dev);
		++dev;
	}
}
    80002b14:	00008067          	ret

0000000080002b18 <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    80002b18:	00351713          	slli	a4,a0,0x3
    80002b1c:	0015051b          	addiw	a0,a0,1
    80002b20:	00000797          	auipc	a5,0x0
    80002b24:	5d878793          	addi	a5,a5,1496 # 800030f8 <levels.0>
    80002b28:	00351513          	slli	a0,a0,0x3
{
    80002b2c:	fd010113          	addi	sp,sp,-48
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    80002b30:	00e78733          	add	a4,a5,a4
    80002b34:	00a78533          	add	a0,a5,a0
{
    80002b38:	02813023          	sd	s0,32(sp)
    80002b3c:	01213823          	sd	s2,16(sp)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    80002b40:	00073403          	ld	s0,0(a4)
    80002b44:	00053903          	ld	s2,0(a0)
{
    80002b48:	01313423          	sd	s3,8(sp)
    80002b4c:	02113423          	sd	ra,40(sp)
    80002b50:	00913c23          	sd	s1,24(sp)
					rc = -rc;
				}
				if (rc > UINT8_MAX) {
					rc = UINT8_MAX;
				}
				dev->state->init_res = rc;
    80002b54:	0ff00993          	li	s3,255
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    80002b58:	03246063          	bltu	s0,s2,80002b78 <z_sys_init_run_level+0x60>
			}
			dev->state->initialized = true;
		}
	}
}
    80002b5c:	02813083          	ld	ra,40(sp)
    80002b60:	02013403          	ld	s0,32(sp)
    80002b64:	01813483          	ld	s1,24(sp)
    80002b68:	01013903          	ld	s2,16(sp)
    80002b6c:	00813983          	ld	s3,8(sp)
    80002b70:	03010113          	addi	sp,sp,48
    80002b74:	00008067          	ret
		const struct device *dev = entry->dev;
    80002b78:	00843483          	ld	s1,8(s0)
		int rc = entry->init(dev);
    80002b7c:	00043783          	ld	a5,0(s0)
    80002b80:	00048513          	mv	a0,s1
    80002b84:	000780e7          	jalr	a5
		if (dev != NULL) {
    80002b88:	02048a63          	beqz	s1,80002bbc <z_sys_init_run_level+0xa4>
				dev->state->init_res = rc;
    80002b8c:	0184b783          	ld	a5,24(s1)
			if (rc != 0) {
    80002b90:	02050063          	beqz	a0,80002bb0 <z_sys_init_run_level+0x98>
				if (rc < 0) {
    80002b94:	41f5571b          	sraiw	a4,a0,0x1f
    80002b98:	00e54533          	xor	a0,a0,a4
    80002b9c:	40e5073b          	subw	a4,a0,a4
    80002ba0:	00070513          	mv	a0,a4
				dev->state->init_res = rc;
    80002ba4:	00e9d463          	bge	s3,a4,80002bac <z_sys_init_run_level+0x94>
    80002ba8:	0ff00513          	li	a0,255
    80002bac:	00a78023          	sb	a0,0(a5)
			dev->state->initialized = true;
    80002bb0:	0007d703          	lhu	a4,0(a5)
    80002bb4:	10076713          	ori	a4,a4,256
    80002bb8:	00e79023          	sh	a4,0(a5)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    80002bbc:	01040413          	addi	s0,s0,16
    80002bc0:	f99ff06f          	j	80002b58 <z_sys_init_run_level+0x40>
